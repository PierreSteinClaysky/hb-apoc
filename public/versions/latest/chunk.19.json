{"Devices Ecosystem/33_dev_push_analysis.md":{"content":"# Message Push Device Analysis (`dev_push.erl`)\r\n\r\n## Overview\r\n\r\nThe `dev_push.erl` module implements a sophisticated message propagation mechanism within HyperBEAM, enabling cross-process communication through recursive message delivery. With 0 downstream dependents, this utility device serves as a critical component in HyperBEAM's distributed messaging architecture, facilitating asynchronous communication between processes both locally and across network boundaries.\r\n\r\nThis module addresses a fundamental requirement in distributed systems: the ability for one process to trigger actions in other processes through message passing. By implementing a push-based messaging pattern, it allows processes to send messages to other processes, evaluate their results, and potentially trigger further message propagation - effectively creating message chains and enabling complex distributed workflows.\r\n\r\nThe module's design emphasizes versatility and resilience, with support for both synchronous and asynchronous operation modes, fallback encoding mechanisms, and robust error handling. Its integration with HyperBEAM's attestation, caching, and HTTP subsystems creates a cohesive framework for secure, reliable message propagation in a distributed environment.\r\n\r\n## Key Characteristics\r\n\r\n- **Recursive Propagation**: Recursively pushes messages to target processes until no more messages remain\r\n- **Sync/Async Modes**: Supports both synchronous and asynchronous execution modes\r\n- **Message Tracking**: Maintains contextual information about message origin and propagation paths\r\n- **Cross-Node Communication**: Enables message pushing across different nodes via HTTP redirection\r\n- **Format Negotiation**: Supports multiple message formats with automatic downgrading (httpsig and ans104)\r\n- **Target Resolution**: Resolves target processes through IDs and hints\r\n- **Comprehensive Logging**: Includes detailed event logging for debugging and tracking message flow\r\n- **Error Handling**: Provides robust error handling for network failures, format issues, and missing targets\r\n- **Process Integration**: Seamlessly integrates with the process device for slot-based message management\r\n- **Cache Integration**: Uses the cache system for message storage and retrieval\r\n- **HTTP Integration**: Leverages HTTP for remote message scheduling and pushing\r\n- **Message Attestation**: Ensures messages are properly attested before propagation\r\n\r\n## Dependencies\r\n\r\n### Library Dependencies\r\n- EUNIT library for testing\r\n\r\n### Upstream Dependencies\r\n- `hb_converge`: For message resolution and field access/modification\r\n- `hb_message`: For message attestation and verification\r\n- `hb_cache`: For message storage and retrieval\r\n- `dev_process`: For process-related operations\r\n- `hb_http`: For remote message pushing via HTTP\r\n- `uri_string`: For parsing and manipulating URIs\r\n\r\n## Implementation Details\r\n\r\n### Core Push Function\r\n\r\nThe main entry point is the `push/3` function, which handles both initial messages and slot-based pushes:\r\n\r\n```erlang\r\npush(Base, Req, Opts) ->\r\n    ModBase = dev_process:as_process(Base, Opts),\r\n    ?event(push, {push_base, {base, ModBase}, {req, Req}}, Opts),\r\n    case hb_converge:get(<<\"slot\">>, {as, <<\"message@1.0\">>, Req}, no_slot, Opts) of\r\n        no_slot ->\r\n            case schedule_initial_message(ModBase, Req, Opts) of\r\n                {ok, Assignment} ->\r\n                    case find_type(hb_converge:get(<<\"body\">>, Assignment, Opts), Opts) of\r\n                        <<\"Message\">> ->\r\n                            ?event(push,\r\n                                {pushing_message,\r\n                                    {base, ModBase},\r\n                                    {assignment, Assignment}\r\n                                },\r\n                                Opts\r\n                            ),\r\n                            push_with_mode(ModBase, Assignment, Opts);\r\n                        <<\"Process\">> ->\r\n                            ?event(push,\r\n                                {initializing_process,\r\n                                    {base, ModBase},\r\n                                    {assignment, Assignment}},\r\n                                Opts\r\n                            ),\r\n                            {ok, Assignment}\r\n                    end;\r\n                {error, Res} -> {error, Res}\r\n            end;\r\n        _ -> push_with_mode(ModBase, Req, Opts)\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Ensures the base is a process\r\n2. Checks if a slot is provided\r\n3. If no slot, schedules the message and processes based on type (Message or Process)\r\n4. If a slot is provided, pushes the message with the appropriate mode\r\n\r\n### Push Mode Selection\r\n\r\nThe module supports both synchronous and asynchronous pushing modes:\r\n\r\n```erlang\r\npush_with_mode(Base, Req, Opts) ->\r\n    Mode = is_async(Base, Req, Opts),\r\n    case Mode of\r\n        <<\"sync\">> ->\r\n            do_push(Base, Req, Opts);\r\n        <<\"async\">> ->\r\n            spawn(fun() -> do_push(Base, Req, Opts) end)\r\n    end.\r\n```\r\n\r\nThe mode is determined by checking various configuration sources:\r\n\r\n```erlang\r\nis_async(Base, Req, Opts) ->\r\n    hb_converge:get_first(\r\n        [\r\n            {Req, <<\"push-mode\">>},\r\n            {Base, <<\"push-mode\">>},\r\n            {Base, <<\"process/push-mode\">>}\r\n        ],\r\n        <<\"sync\">>,\r\n        Opts\r\n    ).\r\n```\r\n\r\n### Core Push Processing\r\n\r\nThe actual push processing occurs in the `do_push/3` function:\r\n\r\n```erlang\r\ndo_push(Base, Assignment, Opts) ->\r\n    Slot = hb_converge:get(<<\"slot\">>, Assignment, Opts),\r\n    ID = dev_process:process_id(Base, #{}, Opts),\r\n    ?event(push, {push_computing_outbox, {process_id, ID}, {slot, Slot}}),\r\n    Result = hb_converge:resolve(\r\n        {as, <<\"process@1.0\">>, Base},\r\n        #{ <<\"path\">> => <<\"compute/results/outbox\">>, <<\"slot\">> => Slot },\r\n        Opts#{ hashpath => ignore }\r\n    ),\r\n    % ... process the results and push to downstream processes ...\r\n```\r\n\r\nThis function:\r\n1. Retrieves the slot number and process ID\r\n2. Computes the outbox for the given slot\r\n3. For each message in the outbox, pushes it to the target process\r\n4. Collects and returns the results of all downstream pushes\r\n\r\n### Message Pushing Logic\r\n\r\nThe core message pushing logic is in `push_result_message/5`:\r\n\r\n```erlang\r\npush_result_message(Base, FromSlot, Key, MsgToPush, Opts) ->\r\n    case hb_converge:get(<<\"target\">>, MsgToPush, undefined, Opts) of\r\n        undefined ->\r\n            ?event(push, {skip_no_target, {key, Key}, MsgToPush}, Opts),\r\n            #{};\r\n        TargetID ->\r\n            % ... schedule the message and push it to the target ...\r\n            case schedule_result(Base, MsgToPush, Opts) of\r\n                {ok, Assignment} ->\r\n                    % ... process the assignment and recursively push ...\r\n                    Resurse = hb_converge:resolve(\r\n                        {as, <<\"process@1.0\">>, TargetAsProcess},\r\n                        #{ <<\"path\">> => <<\"push\">>, <<\"slot\">> => NextSlotOnProc },\r\n                        Opts#{ cache_control => <<\"always\">> }\r\n                    ),\r\n                    % ... handle the results ...\r\n```\r\n\r\nThis function:\r\n1. Checks if a target is specified\r\n2. If a target exists, schedules the message on the target process\r\n3. Recursively calls push on the target process with the new slot\r\n4. Returns the results of the recursive push\r\n\r\n### Message Scheduling\r\n\r\nThe module includes several functions for scheduling messages:\r\n\r\n```erlang\r\nschedule_result(Base, MsgToPush, Opts) ->\r\n    schedule_result(Base, MsgToPush, <<\"httpsig@1.0\">>, Opts).\r\nschedule_result(Base, MsgToPush, Codec, Opts) ->\r\n    % ... prepare and attest the message ...\r\n    SignedReq =\r\n        #{\r\n            <<\"method\">> => <<\"POST\">>,\r\n            <<\"path\">> => <<\"schedule\">>,\r\n            <<\"body\">> =>\r\n                SignedMsg = hb_message:attest(\r\n                    additional_keys(Base, MsgToPush, Opts),\r\n                    Opts,\r\n                    Codec\r\n                )\r\n        },\r\n    % ... resolve the request and handle the response ...\r\n```\r\n\r\nThese functions:\r\n1. Prepare the message with additional keys\r\n2. Attest the message using the specified codec\r\n3. Create a schedule request\r\n4. Resolve the request on the target process\r\n5. Handle the response, including potential redirects and format downgrades\r\n\r\n### Cross-Node Communication\r\n\r\nFor messages that need to be pushed to remote nodes, the module includes `remote_schedule_result/3`:\r\n\r\n```erlang\r\nremote_schedule_result(Location, SignedReq, Opts) ->\r\n    ?event(push, {remote_schedule_result, {location, Location}, {req, SignedReq}}, Opts),\r\n    {Node, RedirectPath} = parse_redirect(Location),\r\n    % ... prepare the request ...\r\n    % Store a copy of the message for ourselves.\r\n    hb_cache:write(SignedReq, Opts),\r\n    case hb_http:post(Node, Path, maps:without([<<\"path\">>], SignedReq), Opts) of\r\n        {ok, Res} ->\r\n            % ... handle the response ...\r\n        {error, Res} ->\r\n            {error, Res}\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Parses the redirect location to extract the node and path\r\n2. Stores a copy of the message in the local cache\r\n3. Posts the request to the remote node\r\n4. Handles the response, including potential further redirects\r\n\r\n## Integration with HyperBEAM\r\n\r\n### Integration with Process Management\r\n\r\nThe module integrates with HyperBEAM's process management system:\r\n\r\n1. **Process Conversion**: Uses `dev_process:as_process/2` to ensure a base is a process\r\n   ```erlang\r\n   ModBase = dev_process:as_process(Base, Opts)\r\n   ```\r\n\r\n2. **Process ID Retrieval**: Uses `dev_process:process_id/3` to get the process ID\r\n   ```erlang\r\n   ID = dev_process:process_id(Base, #{}, Opts)\r\n   ```\r\n\r\n3. **Process Key Handling**: Uses `dev_process:ensure_process_key/2` to ensure process keys are present\r\n   ```erlang\r\n   TargetAsProcess = dev_process:ensure_process_key(TargetBase, Opts)\r\n   ```\r\n\r\n### Integration with Cache System\r\n\r\nThe module integrates with HyperBEAM's cache system:\r\n\r\n1. **Message Retrieval**: Uses `hb_cache:read/2` to retrieve messages\r\n   ```erlang\r\n   {ok, PushBase} = hb_cache:read(Target, Opts)\r\n   ```\r\n\r\n2. **Message Storage**: Uses `hb_cache:write/2` to store messages\r\n   ```erlang\r\n   hb_cache:write(SignedReq, Opts)\r\n   ```\r\n\r\n### Integration with HTTP System\r\n\r\nThe module integrates with HyperBEAM's HTTP system for remote operations:\r\n\r\n1. **Remote Posting**: Uses `hb_http:post/4` to send messages to remote nodes\r\n   ```erlang\r\n   hb_http:post(Node, Path, maps:without([<<\"path\">>], SignedReq), Opts)\r\n   ```\r\n\r\n### Integration with Message System\r\n\r\nThe module integrates with HyperBEAM's message system:\r\n\r\n1. **Message Attestation**: Uses `hb_message:attest/3` to attest messages\r\n   ```erlang\r\n   SignedMsg = hb_message:attest(additional_keys(Base, MsgToPush, Opts), Opts, Codec)\r\n   ```\r\n\r\n2. **Message Verification**: Uses `hb_message:verify/2` to verify messages\r\n   ```erlang\r\n   hb_message:verify(SignedMsg, signers)\r\n   ```\r\n\r\n3. **Message ID Retrieval**: Uses `hb_message:id/3` to get message IDs\r\n   ```erlang\r\n   hb_message:id(FromMsg, all, Opts)\r\n   ```\r\n\r\n## Testing Approach\r\n\r\nThe module includes several complex test functions:\r\n\r\n### Full Push Test\r\n\r\n```erlang\r\nfull_push_test_() ->\r\n    {timeout, 30, fun() ->\r\n        % ... set up test environment ...\r\n        % Create a process\r\n        Msg1 = dev_process:test_aos_process(Opts),\r\n        % Schedule a ping-pong script on it\r\n        Script = ping_pong_script(2),\r\n        {ok, Msg2} = dev_process:schedule_aos_call(Msg1, Script),\r\n        % Push the script and verify execution\r\n        {ok, StartingMsgSlot} =\r\n            hb_converge:resolve(Msg2, #{ <<\"path\">> => <<\"slot\">> }, Opts),\r\n        Msg3 =\r\n            #{\r\n                <<\"path\">> => <<\"push\">>,\r\n                <<\"slot\">> => StartingMsgSlot\r\n            },\r\n        {ok, _} = hb_converge:resolve(Msg1, Msg3, Opts),\r\n        % Check the final result\r\n        ?assertEqual(\r\n            {ok, <<\"Done.\">>},\r\n            hb_converge:resolve(Msg1, <<\"now/results/data\">>, Opts)\r\n        )\r\n    end}.\r\n```\r\n\r\nThis test:\r\n1. Creates a test process\r\n2. Schedules a ping-pong script that sends messages to itself\r\n3. Pushes the initial message\r\n4. Verifies that the script completes correctly\r\n\r\n### Format Negotiation Test\r\n\r\n```erlang\r\npush_prompts_encoding_change_test() ->\r\n    % ... set up test environment ...\r\n    % Create a test message\r\n    Msg = hb_message:attest(#{\r\n        <<\"path\">> => <<\"push\">>,\r\n        <<\"method\">> => <<\"POST\">>,\r\n        <<\"target\">> => <<\"QQiMcAge5ZtxcUV7ruxpi16KYRE8UBP0GAAqCIJPXz0\">>,\r\n        <<\"action\">> => <<\"Eval\">>,\r\n        <<\"data\">> => <<\"print(\\\"Please ignore!\\\")\">>\r\n    }, Opts),\r\n    % Try to resolve it and verify the expected error\r\n    Res =\r\n        hb_converge:resolve_many(\r\n            [\r\n                <<\"QQiMcAge5ZtxcUV7ruxpi16KYRE8UBP0GAAqCIJPXz0\">>,\r\n                {as, <<\"process@1.0\">>, <<>>},\r\n                Msg\r\n            ],\r\n            Opts\r\n        ),\r\n    ?assertMatch({error, #{ <<\"status\">> := 422 }}, Res).\r\n```\r\n\r\nThis test:\r\n1. Creates a message with a specific format\r\n2. Attempts to resolve it\r\n3. Verifies that the expected error occurs due to format issues\r\n\r\nThe module also includes disabled tests for multi-process pushing and pushing with redirect hints, which provide additional test coverage but are not currently active.\r\n\r\n## Observations and Insights\r\n\r\n### Strengths\r\n\r\n1. **Versatile Communication**: Provides a flexible mechanism for cross-process communication both locally and remotely.\r\n\r\n2. **Recursive Propagation**: Enables complex message chains through recursive message pushing.\r\n\r\n3. **Format Negotiation**: Supports multiple message formats with automatic downgrading for compatibility.\r\n\r\n4. **Sync/Async Modes**: Offers both synchronous and asynchronous execution modes for different use cases.\r\n\r\n5. **Comprehensive Logging**: Includes detailed event logging for debugging and monitoring message flow.\r\n\r\n### Design Patterns\r\n\r\n1. **Recursive Chain Pattern**: Implements recursive message chains for propagating messages through multiple processes.\r\n\r\n2. **Format Negotiation Pattern**: Uses a fallback mechanism to try different formats when the preferred one fails.\r\n\r\n3. **Async Processing Pattern**: Provides an option for asynchronous message pushing through process spawning.\r\n\r\n4. **Idempotency Pattern**: Ensures messages are uniquely identified and can be safely retried.\r\n\r\n5. **Redirect Handling Pattern**: Implements proper handling of HTTP redirects for remote operations.\r\n\r\n### Challenges and Limitations\r\n\r\n1. **Complex Error Handling**: The error handling logic is complex and spread across multiple functions.\r\n\r\n2. **Network Dependency**: Heavily relies on network communication for remote pushing, which can introduce latency and reliability issues.\r\n\r\n3. **Test Fragility**: Some tests are disabled due to potential issues, indicating fragility in the testing approach.\r\n\r\n4. **Format Dependency**: Requires specific message formats, which can limit interoperability with external systems.\r\n\r\n5. **Remote Node Trust**: Limited validation of remote nodes, potentially allowing security issues in untrusted environments.\r\n\r\n### Future Opportunities\r\n\r\n1. **Enhanced Error Recovery**: Adding more sophisticated error recovery mechanisms for network failures.\r\n\r\n2. **Improved Format Negotiation**: Expanding format negotiation to handle more formats and be more flexible.\r\n\r\n3. **Performance Optimization**: Optimizing the recursive pushing logic to reduce latency in long message chains.\r\n\r\n4. **Security Enhancements**: Adding more rigorous validation of remote nodes and messages.\r\n\r\n5. **Monitoring and Metrics**: Adding more comprehensive monitoring and metrics for message flow.\r\n\r\n## Architectural Significance\r\n\r\nThe module has several points of architectural significance:\r\n\r\n1. **Distributed Communication**: Enables distributed communication patterns across multiple processes and nodes.\r\n\r\n2. **Message Propagation**: Provides a crucial mechanism for message propagation in a distributed system.\r\n\r\n3. **Cross-Node Interoperability**: Facilitates interoperability between different nodes in a network.\r\n\r\n4. **State Distribution**: Enables distributed state updates through message passing.\r\n\r\n5. **Event Chaining**: Allows for event chaining across multiple processes and nodes.\r\n\r\n## Conclusion\r\n\r\nThe `dev_push.erl` module is a sophisticated component of HyperBEAM's messaging architecture, enabling complex distributed communication patterns through recursive message propagation. Its support for both local and remote pushing, synchronous and asynchronous modes, and multiple message formats makes it a versatile tool for building distributed applications.\r\n\r\nWhile the module's complexity introduces challenges in terms of error handling, testing, and maintenance, its comprehensive design provides a solid foundation for distributed message passing. The integration with HyperBEAM's process, cache, HTTP, and message systems creates a cohesive framework for secure, reliable communication in a distributed environment.\r\n\r\nAs HyperBEAM continues to evolve, this push mechanism will likely remain a critical component for enabling complex distributed workflows, cross-node communication, and event-driven architectures. Future improvements in error handling, format negotiation, and security will further enhance its utility in distributed systems.\r\n\r\n## TO-DO Comments and Incomplete Aspects\r\n\r\nThis module contains a few explicit and implicit TODO items and incomplete aspects:\r\n\r\n1. There's a TODO comment in the `add_attestations` function:\r\n   ```erlang\r\n   % TODO: Filter out attestations from the current node.\r\n   ```\r\n   This suggests the current implementation may include redundant attestations from the local node.\r\n\r\n2. There's a note about an incomplete test case:\r\n   ```erlang\r\n   % Note: This test currently only gets a reply that the message was not\r\n   % trusted by the process. To fix this, we would have to add another \r\n   % trusted authority to the `test_aos_process' call.\r\n   ```\r\n   This indicates that the `push_with_redirect_hint_test_disabled` test is incomplete and requires additional setup to fully test the functionality.\r\n\r\n3. Several test functions are explicitly disabled (`push_with_redirect_hint_test_disabled` and `multi_process_push_test_disabled`), suggesting there are aspects of the functionality that cannot be reliably tested in the current implementation.\r\n\r\n4. There's a comment about potential enhancements to attestation handling:\r\n   ```erlang\r\n   ?no_prod(\"Currently we only attest to the outbox and spawn items. Make it general?\")\r\n   ```\r\n   This indicates a design consideration about whether the attestation mechanism should be generalized to handle more message types.\r\n\r\nThese items represent potential areas for improvement in future versions of the module, particularly around testing reliability, attestation handling, and optimizations for duplicate attestation filtering.\r\n"},"Devices Ecosystem/34_dev_relay_analysis.md":{"content":"# Message Relay Device Analysis (`dev_relay.erl`)\r\n\r\n## Overview\r\n\r\nThe `dev_relay.erl` module implements a message relay mechanism within HyperBEAM, enabling communication between nodes and external HTTP(S) endpoints. With 0 downstream dependents, this utility device serves as a critical bridge between HyperBEAM's internal message system and the wider internet, facilitating both synchronous and asynchronous communication with external services.\r\n\r\nThis module addresses an essential requirement in distributed systems: the ability to interact with external services through standardized protocols. By implementing both synchronous and asynchronous communication patterns, it provides flexibility in how HyperBEAM processes can interact with external systems - allowing for both request-response patterns and fire-and-forget operations.\r\n\r\nThe module's design is elegant in its simplicity, focusing exclusively on the core relay functionality while leveraging HyperBEAM's existing HTTP and messaging infrastructure. This separation of concerns allows it to fulfill its bridging role without duplicating functionality implemented elsewhere in the system.\r\n\r\n## Key Characteristics\r\n\r\n- **Dual Operation Modes**: Supports both synchronous (call) and asynchronous (cast) communication patterns\r\n- **Flexible Configuration**: Allows customization of target, path, method, and client implementation\r\n- **Message Attestation**: Optionally signs messages before relay for security and authentication\r\n- **HTTP Integration**: Leverages HyperBEAM's HTTP subsystem for message routing and delivery\r\n- **Client Customization**: Supports configurable HTTP client implementations\r\n- **Minimal Dependencies**: Maintains a focused implementation with minimal internal dependencies\r\n- **Clean Error Handling**: Delegates error handling to the underlying HTTP subsystem\r\n- **URL Support**: Directly supports full URLs, enabling communication with arbitrary internet endpoints\r\n- **Path Override**: Allows overriding the path for more flexible routing\r\n- **Simple Interface**: Provides a straightforward interface with sensible defaults\r\n\r\n## Dependencies\r\n\r\n### Library Dependencies\r\n- EUNIT library for testing\r\n\r\n### Upstream Dependencies\r\n- `hb_message`: For target finding and message attestation\r\n- `hb_converge`: For message field access and modification\r\n- `hb_http`: For request routing and execution\r\n- `hb_opts`: For configuration access\r\n\r\n## Implementation Details\r\n\r\n### Synchronous Call Function\r\n\r\nThe primary implementation is in the `call/3` function, which handles synchronous relay operations:\r\n\r\n```erlang\r\ncall(M1, RawM2, Opts) ->\r\n    {ok, BaseTarget} = hb_message:find_target(M1, RawM2, Opts),\r\n    RelayPath =\r\n        hb_converge:get_first(\r\n            [\r\n                {RawM2, <<\"relay-path\">>},\r\n                {M1, <<\"relay-path\">>}\r\n            ],\r\n            Opts\r\n        ),\r\n    TargetMod1 =\r\n        case RelayPath of\r\n            not_found -> BaseTarget;\r\n            RPath ->\r\n                ?event({setting_path, {base_target, BaseTarget}, {relay_path, {explicit, RPath}}}),\r\n                hb_converge:set(BaseTarget, <<\"path\">>, RPath, Opts)\r\n        end,\r\n    TargetMod2 =\r\n        case hb_converge:get(<<\"requires-sign\">>, BaseTarget, false, Opts) of\r\n            true -> hb_message:attest(TargetMod1, Opts);\r\n            false -> TargetMod1\r\n        end,\r\n    Client =\r\n        case hb_converge:get(<<\"http-client\">>, BaseTarget, Opts) of\r\n            not_found -> hb_opts:get(relay_http_client, Opts);\r\n            RequestedClient -> RequestedClient\r\n        end,\r\n    ?event({relaying_message, TargetMod2}),\r\n    % Let `hb_http:request/2' handle finding the peer and dispatching the request.\r\n    hb_http:request(TargetMod2, Opts#{ http_client => Client }).\r\n```\r\n\r\nThis function:\r\n1. Finds the target message using `hb_message:find_target`\r\n2. Extracts the relay path, if specified\r\n3. Updates the path in the target message if a relay path was provided\r\n4. Attests (signs) the message if required\r\n5. Determines which HTTP client to use\r\n6. Delegates to `hb_http:request` to handle the actual HTTP communication\r\n\r\n### Asynchronous Cast Function\r\n\r\nThe `cast/3` function implements asynchronous relay operations:\r\n\r\n```erlang\r\ncast(M1, M2, Opts) ->\r\n    spawn(fun() -> call(M1, M2, Opts) end),\r\n    {ok, <<\"OK\">>}.\r\n```\r\n\r\nThis function:\r\n1. Spawns a new Erlang process that executes the `call/3` function\r\n2. Returns immediately with an OK response\r\n3. The spawned process continues execution independently, handling the relay operation\r\n\r\n### Configuration Options\r\n\r\nThe module supports several configuration options:\r\n\r\n- **`target`**: The target message to relay (defaults to the original message)\r\n- **`relay-path`**: The path to relay the message to (defaults to the original path)\r\n- **`method`**: The HTTP method to use (defaults to the original method)\r\n- **`requires-sign`**: Whether the message needs to be attested before relay\r\n- **`http-client`**: The HTTP client implementation to use\r\n\r\nThese options provide flexibility in how messages are relayed, allowing for customization of various aspects of the relay operation.\r\n\r\n## Integration with HyperBEAM\r\n\r\n### Integration with Message System\r\n\r\nThe module integrates with HyperBEAM's message system:\r\n\r\n1. **Target Finding**: Uses `hb_message:find_target/3` to locate the target message\r\n   ```erlang\r\n   {ok, BaseTarget} = hb_message:find_target(M1, RawM2, Opts)\r\n   ```\r\n\r\n2. **Message Attestation**: Uses `hb_message:attest/2` to sign messages when required\r\n   ```erlang\r\n   hb_message:attest(TargetMod1, Opts)\r\n   ```\r\n\r\n### Integration with HTTP System\r\n\r\nThe module integrates with HyperBEAM's HTTP system:\r\n\r\n1. **Request Execution**: Uses `hb_http:request/2` to execute HTTP requests\r\n   ```erlang\r\n   hb_http:request(TargetMod2, Opts#{ http_client => Client })\r\n   ```\r\n\r\n2. **Client Configuration**: Supports custom HTTP client implementations\r\n   ```erlang\r\n   case hb_converge:get(<<\"http-client\">>, BaseTarget, Opts) of\r\n       not_found -> hb_opts:get(relay_http_client, Opts);\r\n       RequestedClient -> RequestedClient\r\n   end\r\n   ```\r\n\r\n### Integration with Configuration System\r\n\r\nThe module integrates with HyperBEAM's configuration system:\r\n\r\n1. **Default Client**: Uses `hb_opts:get/2` to get the default HTTP client\r\n   ```erlang\r\n   hb_opts:get(relay_http_client, Opts)\r\n   ```\r\n\r\n2. **Option Access**: Uses `hb_converge:get/4` and `hb_converge:get_first/3` to access configuration options\r\n   ```erlang\r\n   hb_converge:get(<<\"requires-sign\">>, BaseTarget, false, Opts)\r\n   ```\r\n\r\n## Testing Approach\r\n\r\nThe module includes a basic EUNIT test function:\r\n\r\n```erlang\r\ncall_get_test() ->\r\n    application:ensure_all_started([hb]),\r\n    {ok, #{<<\"body\">> := Body}} =\r\n        hb_converge:resolve(\r\n            #{\r\n                <<\"device\">> => <<\"relay@1.0\">>,\r\n                <<\"method\">> => <<\"GET\">>,\r\n                <<\"path\">> => <<\"https://www.google.com/\">>\r\n            },\r\n            <<\"call\">>,\r\n            #{ protocol => http2 }\r\n        ),\r\n    ?assertEqual(true, byte_size(Body) > 10_000).\r\n```\r\n\r\nThis test:\r\n1. Ensures the HyperBEAM application is started\r\n2. Resolves a message with the relay device, targeting Google's homepage\r\n3. Verifies that a substantial response body (>10KB) is returned\r\n\r\nThis simple test demonstrates the core functionality of the relay device: sending an HTTP request to an external endpoint and receiving a response.\r\n\r\n## Observations and Insights\r\n\r\n### Strengths\r\n\r\n1. **Dual Communication Patterns**: Supports both synchronous and asynchronous communication patterns, providing flexibility for different use cases.\r\n\r\n2. **Simple Interface**: Provides a clean, straightforward interface with sensible defaults, making it easy to use.\r\n\r\n3. **Flexible Configuration**: Offers multiple configuration options for customizing relay behavior.\r\n\r\n4. **Security Integration**: Integrates with HyperBEAM's attestation system for secure message transmission.\r\n\r\n5. **Delegation Pattern**: Delegates complex functionality to specialized subsystems, maintaining a focused implementation.\r\n\r\n### Design Patterns\r\n\r\n1. **Adapter Pattern**: Acts as an adapter between HyperBEAM's message system and external HTTP services.\r\n\r\n2. **Proxy Pattern**: Serves as a proxy for remote operations, hiding the complexities of HTTP communication.\r\n\r\n3. **Actor Pattern**: Uses Erlang's actor model for asynchronous operations, with a process per request.\r\n\r\n4. **Bridge Pattern**: Bridges between different subsystems (messaging and HTTP) without tight coupling.\r\n\r\n5. **Configuration Object Pattern**: Uses a configuration map to customize behavior rather than fixed parameters.\r\n\r\n### Challenges and Limitations\r\n\r\n1. **Limited Error Handling**: Relies on underlying systems for error handling, potentially making error diagnosis complex.\r\n\r\n2. **Network Dependency**: Heavily dependent on network connectivity and reliability.\r\n\r\n3. **Limited Retry Logic**: No built-in retry mechanisms for failed requests.\r\n\r\n4. **Minimal Authentication Options**: Limited options for authentication beyond message attestation.\r\n\r\n5. **Basic Testing**: The testing approach is minimal, covering only the happy path.\r\n\r\n### Future Opportunities\r\n\r\n1. **Enhanced Error Handling**: Adding more sophisticated error handling and reporting.\r\n\r\n2. **Retry Mechanisms**: Implementing configurable retry logic for resilience.\r\n\r\n3. **Authentication Options**: Adding support for various authentication methods.\r\n\r\n4. **Response Transformation**: Adding capabilities for transforming responses before returning them.\r\n\r\n5. **Circuit Breaking**: Implementing circuit breaking for improved reliability.\r\n\r\n## Architectural Significance\r\n\r\nThe module has several points of architectural significance:\r\n\r\n1. **External Integration**: Provides a clean bridge between HyperBEAM and external systems.\r\n\r\n2. **Communication Patterns**: Supports both synchronous and asynchronous communication patterns.\r\n\r\n3. **Protocol Adaptation**: Adapts between HyperBEAM's message protocol and HTTP.\r\n\r\n4. **Security Boundary**: Forms part of the security boundary between HyperBEAM and external systems.\r\n\r\n5. **Service Gateway**: Acts as a gateway for accessing external services.\r\n\r\n## Conclusion\r\n\r\nThe `dev_relay.erl` module represents a simple but essential component of HyperBEAM's external communication architecture. By providing a bridge between HyperBEAM's message system and external HTTP(S) endpoints, it enables integration with a wide range of external services and systems.\r\n\r\nThe module's dual support for synchronous and asynchronous communication patterns provides flexibility for different use cases, while its clean interface and sensible defaults make it easy to use. Its integration with HyperBEAM's messaging, HTTP, and configuration systems creates a cohesive framework for external communication.\r\n\r\nWhile there are opportunities for enhancement in areas like error handling, retry logic, and authentication options, the current implementation provides a solid foundation for external communication. As HyperBEAM continues to evolve, this relay capability will likely remain a key component for integrating with external systems and services.\r\n\r\n## TO-DO Comments and Incomplete Aspects\r\n\r\nThis module does not contain any explicit TO-DO comments, which suggests it is relatively complete for its intended purpose. However, some aspects that could be considered candidates for future enhancement include:\r\n\r\n1. The error handling is minimal, relying on the underlying HTTP subsystem. More sophisticated error handling and reporting could be beneficial.\r\n\r\n2. There's no explicit retry logic for failed requests. Adding configurable retry mechanisms could improve resilience.\r\n\r\n3. Authentication options are limited to message attestation. Supporting additional authentication methods could enhance flexibility.\r\n\r\n4. Testing coverage is minimal, with only a basic happy path test. More comprehensive testing, including error cases, would strengthen the implementation.\r\n\r\nThese are not explicitly marked as TO-DO items but represent areas where the module could potentially be expanded or improved in the future.\r\n"},"Devices Ecosystem/35_dev_delegated_compute_analysis.md":{"content":"# Delegated Computation Device Analysis (`dev_delegated_compute.erl`)\r\n\r\n## Overview\r\n\r\nThe `dev_delegated_compute.erl` module implements a wrapper within HyperBEAM that enables computation offloading to remote machines. With 0 downstream dependents, this utility device serves as a bridge between local processes and remote computation resources, facilitating distributed processing through the JSON interface.\r\n\r\nThis module addresses an important requirement in distributed systems: the ability to delegate computation to specialized or remote nodes while maintaining the messaging and state model of the local system. It can function both as a standalone device to bring trusted results into the local node, or as an execution device for AO processes, enabling flexible deployment architectures.\r\n\r\nThe module's design is lightweight and focused, implementing the minimal set of handlers required for computation while leveraging HyperBEAM's relay and JSON interface systems for the actual remote communication. This separation of concerns allows it to focus exclusively on the bridging and result processing aspects of remote computation.\r\n\r\n## Key Characteristics\r\n\r\n- **Remote Computation**: Enables computation execution on remote machines\r\n- **JSON Interface Integration**: Implements the JSON-Iface for cross-system compatibility\r\n- **Minimal State Handling**: Provides simple pass-through implementations for state-related operations\r\n- **Slot-Based Processing**: Uses the slot system for tracking computation instances\r\n- **Process ID Routing**: Routes computation requests using process IDs\r\n- **Result Format Conversion**: Converts JSON results back into HyperBEAM messages\r\n- **Result Namespacing**: Uses prefixing to organize results in the message structure\r\n- **Dual Output Formats**: Stores both processed message results and raw JSON results\r\n- **Relay Integration**: Leverages the relay device for actual remote communication\r\n- **Error Propagation**: Maintains error context through the delegation chain\r\n\r\n## Dependencies\r\n\r\n### Library Dependencies\r\n- EUNIT library for testing\r\n\r\n### Upstream Dependencies\r\n- `dev_process`: For process ID retrieval\r\n- `hb_converge`: For message field access and resolution\r\n- `dev_stack`: For output prefix determination\r\n- `dev_json_iface`: For JSON-to-message conversion\r\n- `dev_relay` (indirect): Used through resolve for remote communication\r\n\r\n## Implementation Details\r\n\r\n### Core Handlers\r\n\r\nThe module implements four standard device handlers:\r\n\r\n```erlang\r\ninit(Msg1, _Msg2, _Opts) ->\r\n    {ok, Msg1}.\r\nnormalize(Msg1, _Msg2, _Opts) -> {ok, Msg1}.\r\nsnapshot(Msg1, _Msg2, _Opts) -> {ok, Msg1}.\r\n```\r\n\r\nThese handlers are simple pass-through implementations that maintain the current state without modification, reflecting the stateless nature of this device.\r\n\r\n### Compute Handler\r\n\r\nThe primary functionality is in the `compute/3` function:\r\n\r\n```erlang\r\ncompute(Msg1, Msg2, Opts) ->\r\n    RawProcessID = dev_process:process_id(Msg1, #{}, Opts),\r\n    Slot = hb_converge:get(<<\"slot\">>, Msg2, Opts),\r\n    OutputPrefix = dev_stack:prefix(Msg1, Msg2, Opts),\r\n    ProcessID =\r\n        case RawProcessID of\r\n            not_found -> hb_converge:get(<<\"process-id\">>, Msg2, Opts);\r\n            ProcID -> ProcID\r\n        end,\r\n    Res = do_compute(ProcessID, Slot, Opts),\r\n    case Res of\r\n        {ok, JSONRes} ->\r\n            ?event(\r\n                {compute_lite_res,\r\n                    {process_id, ProcessID},\r\n                    {slot, Slot},\r\n                    {json_res, {string, JSONRes}},\r\n                    {req, Msg2}\r\n                }\r\n            ),\r\n            {ok, Msg} = dev_json_iface:json_to_message(JSONRes, Opts),\r\n            {ok,\r\n                hb_converge:set(\r\n                    Msg1,\r\n                    #{\r\n                        <<OutputPrefix/binary, \"/results\">> => Msg,\r\n                        <<OutputPrefix/binary, \"/results/json\">> =>\r\n                            #{\r\n                                <<\"content-type\">> => <<\"application/json\">>,\r\n                                <<\"body\">> => JSONRes\r\n                            }\r\n                    },\r\n                    Opts\r\n                )\r\n            };\r\n        {error, Error} ->\r\n            {error, Error}\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Retrieves the process ID from the message or falls back to the process-id field\r\n2. Gets the slot number from the request message\r\n3. Determines the output prefix for result storage\r\n4. Calls `do_compute` to execute the remote computation\r\n5. Processes the JSON result, converting it to a message format\r\n6. Stores both the converted message and the raw JSON in the result message\r\n7. Propagates any errors from the computation\r\n\r\n### Remote Computation\r\n\r\nThe actual remote computation is handled by the `do_compute/3` function:\r\n\r\n```erlang\r\ndo_compute(ProcID, Slot, Opts) ->\r\n    Res = \r\n        hb_converge:resolve(#{ <<\"device\">> => <<\"relay@1.0\">> }, #{\r\n            <<\"path\">> => <<\"call\">>,\r\n            <<\"relay-path\">> =>\r\n                <<\r\n                    \"/result/\",\r\n                    (integer_to_binary(Slot))/binary,\r\n                    \"?process-id=\",\r\n                    ProcID/binary\r\n                >>\r\n            },\r\n            Opts\r\n        ),\r\n    case Res of\r\n        {ok, Response} ->\r\n            JSONRes = hb_converge:get(<<\"body\">>, Response, Opts),\r\n            ?event({\r\n                delegated_compute_res_metadata,\r\n                {req, maps:without([<<\"body\">>], Response)}\r\n            }),\r\n            {ok, JSONRes};\r\n        {Err, Error} when Err == error; Err == failure ->\r\n            {error, Error}\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Uses the relay device to make a remote call to the computation endpoint\r\n2. Constructs a path that includes the slot number and process ID\r\n3. Retrieves the JSON result from the response body\r\n4. Logs the response metadata for debugging\r\n5. Returns the JSON result or propagates any errors\r\n\r\n## Integration with HyperBEAM\r\n\r\n### Integration with Process Management\r\n\r\nThe module integrates with HyperBEAM's process management system:\r\n\r\n1. **Process ID Retrieval**: Uses `dev_process:process_id/3` to get the process ID\r\n   ```erlang\r\n   RawProcessID = dev_process:process_id(Msg1, #{}, Opts)\r\n   ```\r\n\r\n2. **Fallback Process ID**: Falls back to extracting the process ID from the request if not found in the base message\r\n   ```erlang\r\n   not_found -> hb_converge:get(<<\"process-id\">>, Msg2, Opts)\r\n   ```\r\n\r\n### Integration with Stack System\r\n\r\nThe module integrates with HyperBEAM's stack system:\r\n\r\n1. **Prefix Determination**: Uses `dev_stack:prefix/3` to determine the output prefix for results\r\n   ```erlang\r\n   OutputPrefix = dev_stack:prefix(Msg1, Msg2, Opts)\r\n   ```\r\n\r\n### Integration with JSON Interface\r\n\r\nThe module integrates with HyperBEAM's JSON interface:\r\n\r\n1. **JSON Conversion**: Uses `dev_json_iface:json_to_message/2` to convert JSON to a message\r\n   ```erlang\r\n   {ok, Msg} = dev_json_iface:json_to_message(JSONRes, Opts)\r\n   ```\r\n\r\n### Integration with Relay System\r\n\r\nThe module indirectly integrates with HyperBEAM's relay system:\r\n\r\n1. **Remote Call**: Uses `hb_converge:resolve/3` with the relay device to make remote calls\r\n   ```erlang\r\n   hb_converge:resolve(#{ <<\"device\">> => <<\"relay@1.0\">> }, #{ ... }, Opts)\r\n   ```\r\n\r\n## Observations and Insights\r\n\r\n### Strengths\r\n\r\n1. **Separation of Concerns**: Clearly separates the delegation logic from the actual remote communication and result processing.\r\n\r\n2. **Minimal Implementation**: Maintains a focused implementation that handles only the essential aspects of delegation.\r\n\r\n3. **Dual Result Storage**: Stores both the processed message and the raw JSON, providing flexibility in how results are accessed.\r\n\r\n4. **Fallback Mechanisms**: Implements fallbacks for process ID retrieval, enhancing robustness.\r\n\r\n5. **Transparent Error Handling**: Propagates errors from the remote computation to the caller.\r\n\r\n### Design Patterns\r\n\r\n1. **Adapter Pattern**: Acts as an adapter between HyperBEAM's message system and remote computation services.\r\n\r\n2. **Proxy Pattern**: Serves as a proxy for remote computation operations.\r\n\r\n3. **Facade Pattern**: Provides a simplified interface for remote computation through the compute handler.\r\n\r\n4. **Delegation Pattern**: Delegates the actual communication to the relay device.\r\n\r\n5. **Result Transformation Pattern**: Transforms JSON results into message format for integration with the rest of the system.\r\n\r\n### Challenges and Limitations\r\n\r\n1. **Limited Error Context**: Error details from remote computation may be limited by what the relay returns.\r\n\r\n2. **No Retry Mechanism**: Does not implement retry logic for failed remote computations.\r\n\r\n3. **Synchronous Operation**: Operates synchronously, which could block if remote computation takes a long time.\r\n\r\n4. **Limited Configuration**: Provides minimal options for configuring the remote computation behavior.\r\n\r\n5. **No Authentication Control**: Relies on the underlying relay for authentication and security.\r\n\r\n### Future Opportunities\r\n\r\n1. **Asynchronous Operation**: Adding support for asynchronous computation delegation.\r\n\r\n2. **Enhanced Error Information**: Improving error context and handling for remote failures.\r\n\r\n3. **Retry Logic**: Implementing configurable retry mechanisms for resilience.\r\n\r\n4. **Result Caching**: Adding caching of computation results to reduce redundant remote calls.\r\n\r\n5. **Computation Routing**: Adding support for routing different computations to different remote nodes.\r\n\r\n## Architectural Significance\r\n\r\nThe module has several points of architectural significance:\r\n\r\n1. **Distributed Computation**: Enables distributed computation patterns across multiple nodes.\r\n\r\n2. **System Integration**: Bridges the local message system with remote computation services.\r\n\r\n3. **Cross-System Compatibility**: Facilitates integration with non-HyperBEAM systems through the JSON interface.\r\n\r\n4. **AO Integration**: Supports the AO model by serving as an execution device for AO processes.\r\n\r\n5. **Computation Offloading**: Enables offloading of resource-intensive computations to specialized nodes.\r\n\r\n## Conclusion\r\n\r\nThe `dev_delegated_compute.erl` module represents a simple but powerful component of HyperBEAM's distributed computation architecture. By providing a bridge between local processes and remote computation resources, it enables flexible deployment architectures and computation offloading.\r\n\r\nThe module's lightweight design, focused on delegation and result processing while leveraging existing systems for communication and format conversion, makes it an elegant solution to the remote computation problem. Its integration with HyperBEAM's process, stack, JSON interface, and relay systems creates a cohesive framework for distributed computation.\r\n\r\nWhile there are opportunities for enhancement in areas like asynchronous operation, error handling, and configuration options, the current implementation provides a solid foundation for remote computation delegation. As HyperBEAM continues to evolve, this delegation capability will likely remain a key component for distributed computation architectures.\r\n\r\n## TO-DO Comments and Incomplete Aspects\r\n\r\nThis module does not contain any explicit TO-DO comments, which suggests it is relatively complete for its intended purpose. However, some aspects that could be considered candidates for future enhancement include:\r\n\r\n1. The error handling is minimal, with limited context about remote computation failures. More sophisticated error handling and reporting could be beneficial.\r\n\r\n2. There's no explicit retry logic for failed remote computations. Adding configurable retry mechanisms could improve resilience.\r\n\r\n3. The module operates synchronously, which could be limiting for long-running computations. Adding asynchronous operation support would enhance flexibility.\r\n\r\n4. There's no caching mechanism for computation results, which could lead to redundant remote calls. Implementing result caching could improve performance.\r\n\r\nThese are not explicitly marked as TO-DO items but represent areas where the module could potentially be expanded or improved in the future.\r\n"}}