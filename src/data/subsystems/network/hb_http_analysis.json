{
  "name": "`hb_http",
  "subsystem": "network",
  "filename": "hb_http.erl",
  "content": "# `hb_http.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_http.erl` serves as HyperBEAM's core HTTP request/reply functionality, providing a crucial bridge between the message-based internal architecture and external HTTP communication. The module abstracts HTTP operations into message transformations, allowing HyperBEAM components to interact with external systems through a unified interface that maintains the message-centric design philosophy.\r\n\r\nRather than exposing raw HTTP mechanics, the module transforms HTTP interactions into message operations, maintaining consistency with the system's broader architecture. It handles the complex task of encoding and decoding between HyperBEAM's internal message format and the HTTP protocol, with support for different content formats through pluggable codecs.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Message-Centric Design**: Treats HTTP as a transport for messages rather than a separate protocol\r\n- **Bidirectional Conversion**: Converts between internal message formats and HTTP requests/responses\r\n- **Content Negotiation**: Supports multiple content formats through codec selection\r\n- **Signature Verification**: Validates message signatures for secure communication\r\n- **Routing Support**: Handles complex routing decisions through integration with `dev_router`\r\n- **Multi-Node Requests**: Capable of dispatching requests to multiple nodes and aggregating results\r\n- **CORS Support**: Automatically handles Cross-Origin Resource Sharing headers\r\n- **Deep Integration**: Works closely with HyperBEAM's message and device systems\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_converge`: For message resolution and key lookup\r\n- `hb_message`: For message conversion and signature verification\r\n- `hb_http_client`: For making actual HTTP requests\r\n- `hb_opts`: For accessing configuration options\r\n- `hb_path`: For path normalization\r\n- `hb_util`: For utility functions\r\n- `hb_cache`: For storing signed messages\r\n- `dev_router`: For message routing decisions\r\n- `dev_codec_httpsig`: For HTTP signature handling\r\n- `dev_codec_httpsig_conv`: For HTTP signature conversions\r\n- `ar_bundles`: For ANS-104 message serialization/deserialization\r\n- `cowboy_req`: For HTTP request/response handling\r\n- `httpc`: For HTTP client configuration\r\n- `uri_string`: For URI parsing\r\n\r\n\n\n## Implementation Details\r\n\r\n### HTTP Request Handling\r\n\r\nThe module provides several functions for making HTTP requests, with varying levels of abstraction:\r\n\r\n```erlang\r\n% High-level functions\r\nget(Node, Opts) -> get(Node, <<\"/\">>, Opts).\r\nget(Node, PathBin, Opts) when is_binary(PathBin) ->\r\n    get(Node, #{ <<\"path\">> => PathBin }, Opts);\r\nget(Node, Message, Opts) ->\r\n    request(\r\n        <<\"GET\">>,\r\n        Node,\r\n        hb_converge:get(<<\"path\">>, Message, <<\"/\">>, Opts),\r\n        Message,\r\n        Opts\r\n    ).\r\n\r\npost(Node, Message, Opts) ->\r\n    post(Node,\r\n        hb_converge:get(\r\n            <<\"path\">>,\r\n            Message,\r\n            <<\"/\">>,\r\n            Opts#{ topic => converge_internal }\r\n        ),\r\n        Message,\r\n        Opts\r\n    ).\r\n```\r\n\r\nThese functions ultimately call `request/5`, which handles the actual HTTP request processing:\r\n\r\n```erlang\r\nrequest(Method, Peer, Path, RawMessage, Opts) ->\r\n    Req = prepare_request(\r\n        hb_converge:get(\r\n            <<\"codec-device\">>,\r\n            RawMessage,\r\n            <<\"httpsig@1.0\">>,\r\n            Opts\r\n        ),\r\n        Method,\r\n        Peer,\r\n        Path,\r\n        RawMessage,\r\n        Opts\r\n    ),\r\n    {_ErlStatus, Status, Headers, Body} = hb_http_client:req(Req, Opts),\r\n    % Process the response...\r\n```\r\n\r\nThis function prepares the request with the appropriate codec, sends it via `hb_http_client`, and then processes the response into a HyperBEAM message format.\r\n\r\n### Content Negotiation\r\n\r\nThe module implements content negotiation through codec selection:\r\n\r\n```erlang\r\naccept_to_codec(TABMReq, Opts) ->\r\n    AcceptCodec =\r\n        maps:get(\r\n            <<\"accept-codec\">>,\r\n            TABMReq,\r\n            mime_to_codec(maps:get(<<\"accept\">>, TABMReq, <<\"*/*\">>), Opts)\r\n        ),\r\n    case AcceptCodec of\r\n        not_specified -> default_codec(Opts);\r\n        _ -> AcceptCodec\r\n    end.\r\n\r\nmime_to_codec(<<\"application/\", Mime/binary>>, Opts) ->\r\n    Name =\r\n        case binary:match(Mime, <<\"@\">>) of\r\n            nomatch -> << Mime/binary, \"@1.0\" >>;\r\n            _ -> Mime\r\n        end,\r\n    try hb_converge:message_to_device(#{ <<\"device\">> => Name }, Opts)\r\n    catch _:Error -> default_codec(Opts)\r\n    end;\r\n% Other cases...\r\n```\r\n\r\nThis allows clients to specify their preferred content format, with the system selecting an appropriate codec for encoding and decoding messages.\r\n\r\n### Multi-Node Requests\r\n\r\nThe module can handle requests to multiple nodes concurrently:\r\n\r\n```erlang\r\nmultirequest(Config, Method, Path, Message, Opts) ->\r\n    MultiOpts = #{\r\n        nodes := Nodes,\r\n        responses := Responses,\r\n        stop_after := StopAfter,\r\n        accept_status := Statuses,\r\n        parallel := Parallel\r\n    } = multirequest_opts(Config, Message, Opts),\r\n    AllResults =\r\n        if Parallel ->\r\n            parallel_multirequest(\r\n                Nodes, Responses, StopAfter, Method, Path, Message, Statuses, Opts);\r\n        true ->\r\n            serial_multirequest(\r\n                Nodes, Responses, Method, Path, Message, Statuses, Opts)\r\n        end,\r\n    % Process results...\r\n```\r\n\r\nThis functionality allows for:\r\n- Parallel or serial execution\r\n- Configurable success criteria (how many responses are needed)\r\n- Early termination options\r\n- Status code filtering\r\n\r\n### HTTP Response Generation\r\n\r\nFor server-side HTTP responses, the module provides the `reply` function:\r\n\r\n```erlang\r\nreply(Req, TABMReq, Message, Opts) ->\r\n    Status =\r\n        case hb_converge:get(<<\"status\">>, Message, Opts) of\r\n            not_found -> 200;\r\n            S-> S\r\n        end,\r\n    reply(Req, TABMReq, Status, Message, Opts).\r\n\r\nreply(Req, TABMReq, Status, RawMessage, Opts) ->\r\n    Message = hb_converge:normalize_keys(RawMessage),\r\n    {ok, HeadersBeforeCors, EncodedBody} = encode_reply(TABMReq, Message, Opts),\r\n    % Add CORS headers and send response...\r\n```\r\n\r\nThis function converts a HyperBEAM message into an HTTP response, handling:\r\n- Status code selection\r\n- CORS header addition\r\n- Content encoding via the appropriate codec\r\n- Cookie handling\r\n\r\n### Message Security\r\n\r\nThe module includes security features for message verification:\r\n\r\n```erlang\r\nhttp_sig_to_tabm_singleton(Req = #{ headers := RawHeaders }, Body, Opts) ->\r\n    Msg = dev_codec_httpsig_conv:from(\r\n        RawHeaders#{ <<\"body\">> => Body }\r\n    ),\r\n    {ok, SignedMsg} =\r\n        dev_codec_httpsig:reset_hmac(\r\n            hb_util:ok(remove_unsigned_fields(Msg, Opts))\r\n        ),\r\n    ForceSignedRequests = hb_opts:get(force_signed_requests, false, Opts),\r\n    case (not ForceSignedRequests) orelse hb_message:verify(SignedMsg) of\r\n        true ->\r\n            % Signature verified...\r\n            maybe_add_unsigned(Req, SignedMsg, Opts);\r\n        false ->\r\n            % Signature verification failed...\r\n            throw({invalid_signature, SignedMsg})\r\n    end.\r\n```\r\n\r\nThis ensures that signed messages are properly verified, with an option to require signatures for all requests.\r\n\r\n\n\n## Tests\r\n\r\nThe module includes extensive tests that verify:\r\n\r\n1. **Basic Functionality**: Simple HTTP request/response cycles\r\n2. **Signature Verification**: Both signed and unsigned message handling\r\n3. **Nested Path Resolution**: Accessing nested data through path expressions\r\n4. **WASM Integration**: Running WebAssembly computations via HTTP\r\n5. **CORS Support**: Proper handling of CORS headers\r\n6. **Content Negotiation**: Using different content formats (ANS-104, HTTPSig)\r\n\r\nThese tests demonstrate the module's capabilities and ensure its correct operation in various scenarios.\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Uses `hb_converge` for message resolution and key lookup\r\n- Uses `hb_message` for message conversion and signature verification\r\n- Uses `hb_opts` for configuration access\r\n- Uses `hb_path` for path normalization\r\n\r\n### Integration with Storage Subsystem\r\n\r\n- Uses `hb_cache` for storing signed messages received over HTTP\r\n\r\n### Integration with Device Subsystem\r\n\r\n- Uses `dev_router` for message routing decisions\r\n- Uses `dev_codec_httpsig` and `dev_codec_httpsig_conv` for HTTP signature handling\r\n\r\n### Integration with Arweave Subsystem\r\n\r\n- Uses `ar_bundles` for ANS-104 message serialization/deserialization",
  "description": "`hb_http.erl` serves as HyperBEAM's core HTTP request/reply functionality, providing a crucial bridge between the message-based internal architecture and external HTTP communication. The module abstracts HTTP operations into message transformations, allowing HyperBEAM components to interact with external systems through a unified interface that maintains the message-centric design philosophy.",
  "hasCode": true
}