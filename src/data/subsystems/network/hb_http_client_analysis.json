{
  "name": "`hb_http_client",
  "subsystem": "network",
  "filename": "hb_http_client.erl",
  "content": "# `hb_http_client.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_http_client.erl` implements the client-side component of HyperBEAM's HTTP functionality, managing outbound HTTP connections and requests to external services. This module provides a layer of abstraction over lower-level HTTP client libraries, supporting both `gun` (an Erlang HTTP client based on the BEAM socket interface) and `httpc` (the standard OTP HTTP client).\r\n\r\nThe module is implemented as a `gen_server` that maintains connection pools, handles connection failures and retries, and provides instrumentation for metrics collection. It focuses on connection management and request handling, providing a reliable interface for other modules (particularly `hb_http.erl`) to make HTTP requests.\r\n\r\nAs noted in the module's documentation, it originated from the Arweave project and was modified for use in HyperBEAM, showing the system's integration with and adaptation of external components.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Connection Pooling**: Manages a pool of HTTP connections for efficient resource usage\r\n- **Dual Client Support**: Can use either `gun` or `httpc` as the underlying HTTP client\r\n- **Connection Management**: Handles connection establishment, monitoring, and cleanup\r\n- **Request Processing**: Sends HTTP requests and processes responses\r\n- **Error Handling**: Detects and handles various network and protocol errors\r\n- **Retry Logic**: Supports connection re-establishment on certain types of failures\r\n- **Metrics Collection**: Integrates with Prometheus for performance monitoring\r\n- **Protocol Flexibility**: Supports HTTP, HTTPS, and multiple HTTP versions\r\n- **Streaming Support**: Handles chunked responses and streaming data\r\n- **Rate Limiting**: Integrates with `ar_rate_limiter` for request throttling\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `gen_server`: For the OTP server behavior\r\n- `prometheus_*`: For metrics collection and reporting\r\n- `gun`: For the primary HTTP client implementation\r\n- `httpc`: For the alternative HTTP client implementation\r\n- `ar_rate_limiter`: For request throttling\r\n- `hb_opts`: For configuration access\r\n- `hb_util`: For utility functions\r\n- `uri_string`: For URI parsing\r\n- `ar_util`: For peer formatting utilities\r\n- `inet`: For timeout handling\r\n\r\n\n\n## Implementation Details\r\n\r\n### Connection Management\r\n\r\nThe module maintains a pool of connections, tracked by peer address:\r\n\r\n```erlang\r\n-record(state, {\r\n    pid_by_peer = #{},\r\n    status_by_pid = #{},\r\n    opts = #{}\r\n}).\r\n```\r\n\r\nConnections are established on demand and are reused for subsequent requests to the same peer:\r\n\r\n```erlang\r\nhandle_call({get_connection, Args}, From,\r\n        #state{ pid_by_peer = PIDPeer, status_by_pid = StatusByPID } = State) ->\r\n    Peer = maps:get(peer, Args),\r\n    case maps:get(Peer, PIDPeer, not_found) of\r\n        not_found ->\r\n            {ok, PID} = open_connection(Args, State#state.opts),\r\n            MonitorRef = monitor(process, PID),\r\n            PIDPeer2 = maps:put(Peer, PID, PIDPeer),\r\n            StatusByPID2 =\r\n                maps:put(\r\n                    PID,\r\n                    {{connecting, [{From, Args}]}, MonitorRef, Peer},\r\n                    StatusByPID\r\n                ),\r\n            {\r\n                reply,\r\n                {ok, PID},\r\n                State#state{\r\n                    pid_by_peer = PIDPeer2,\r\n                    status_by_pid = StatusByPID2\r\n                }\r\n            };\r\n        PID ->\r\n            % Connection exists...\r\n```\r\n\r\nConnections are monitored for failures, and the module handles connection lifecycle events such as `gun_up`, `gun_error`, and `gun_down`:\r\n\r\n```erlang\r\nhandle_info({gun_up, PID, _Protocol}, #state{ status_by_pid = StatusByPID } = State) ->\r\n    % Handle connection established\r\n    \r\nhandle_info({gun_error, PID, Reason}, #state{ ... } = State) ->\r\n    % Handle connection error\r\n    \r\nhandle_info({gun_down, PID, Protocol, Reason, _KilledStreams, _UnprocessedStreams}, #state{ ... } = State) ->\r\n    % Handle connection down\r\n```\r\n\r\n### Request Handling\r\n\r\nThe module provides two main request functions: `gun_req` for using the `gun` client and `httpc_req` for using the standard `httpc` client:\r\n\r\n```erlang\r\nreq(Args, Opts) -> req(Args, false, Opts).\r\nreq(Args, ReestablishedConnection, Opts) ->\r\n    case hb_opts:get(http_client, gun, Opts) of\r\n        gun -> gun_req(Args, ReestablishedConnection, Opts);\r\n        httpc -> httpc_req(Args, ReestablishedConnection, Opts)\r\n    end.\r\n```\r\n\r\nFor `gun_req`, the function:\r\n1. Gets a connection from the connection pool\r\n2. Throttles the request if needed\r\n3. Sends the request and waits for a response\r\n4. Handles various response formats and errors\r\n5. Collects metrics about the request\r\n\r\n```erlang\r\ngun_req(Args, ReestablishedConnection, Opts) ->\r\n    StartTime = erlang:monotonic_time(),\r\n    #{ peer := Peer, path := Path, method := Method } = Args,\r\n    Response =\r\n        case catch gen_server:call(?MODULE, {get_connection, Args}, infinity) of\r\n            {ok, PID} ->\r\n                ar_rate_limiter:throttle(Peer, Path, Opts),\r\n                case request(PID, Args, Opts) of\r\n                    % Handle various response scenarios...\r\n                end;\r\n            % Handle errors...\r\n        end,\r\n    % Record metrics...\r\n    Response.\r\n```\r\n\r\nFor `httpc_req`, the function directly uses the standard OTP HTTP client to make the request:\r\n\r\n```erlang\r\nhttpc_req(Args, _, Opts) ->\r\n    #{\r\n        peer := Peer,\r\n        path := Path,\r\n        method := RawMethod,\r\n        headers := Headers,\r\n        body := Body\r\n    } = Args,\r\n    % Prepare the request...\r\n    case httpc:request(Method, Request, [], HTTPCOpts) of\r\n        {ok, {{_, Status, _}, RawRespHeaders, RespBody}} ->\r\n            % Process response...\r\n        {error, Reason} ->\r\n            % Handle error...\r\n    end.\r\n```\r\n\r\n### Response Processing\r\n\r\nThe module handles various response formats, including chunked responses:\r\n\r\n```erlang\r\nawait_response(Args, Opts) ->\r\n    #{ pid := PID, stream_ref := Ref, timer := Timer, limit := Limit,\r\n            counter := Counter, acc := Acc, method := Method, path := Path } = Args,\r\n    case gun:await(PID, Ref, inet:timeout(Timer)) of\r\n        {response, fin, Status, Headers} ->\r\n            % Complete response with no body\r\n            \r\n        {response, nofin, Status, Headers} ->\r\n            % Response headers received, awaiting body\r\n            \r\n        {data, nofin, Data} ->\r\n            % Partial body chunk received\r\n            \r\n        {data, fin, Data} ->\r\n            % Final body chunk received\r\n            \r\n        % Handle various error conditions...\r\n    end.\r\n```\r\n\r\nFor chunked responses, the module accumulates the chunks until the complete response is received, with optional size limits:\r\n\r\n```erlang\r\n{data, nofin, Data} ->\r\n    case Limit of\r\n        infinity ->\r\n            await_response(Args#{ acc := [Acc | Data] }, Opts);\r\n        Limit ->\r\n            Counter2 = size(Data) + Counter,\r\n            case Limit >= Counter2 of\r\n                true ->\r\n                    await_response(\r\n                        Args#{\r\n                            counter := Counter2,\r\n                            acc := [Acc | Data]\r\n                        },\r\n                        Opts\r\n                    );\r\n                false ->\r\n                    % Size limit exceeded\r\n                    {error, too_much_data}\r\n            end\r\n    end;\r\n```\r\n\r\n### Metrics Collection\r\n\r\nThe module initializes and collects several Prometheus metrics for monitoring HTTP client performance:\r\n\r\n```erlang\r\ninit(Opts) ->\r\n    prometheus_counter:new([\r\n        {name, gun_requests_total},\r\n        {labels, [http_method, route, status_class]},\r\n        {\r\n            help,\r\n            \"The total number of GUN requests.\"\r\n        }\r\n    ]),\r\n    prometheus_gauge:new([{name, outbound_connections},\r\n        {help, \"The current number of the open outbound network connections\"}]),\r\n    prometheus_histogram:new([\r\n        {name, http_request_duration_seconds},\r\n        {buckets, [0.01, 0.1, 0.5, 1, 5, 10, 30, 60]},\r\n        {labels, [http_method, route, status_class]},\r\n        {\r\n            help,\r\n            \"The total duration of an hb_http_client:req call.\"\r\n        }\r\n    ]),\r\n    % Additional metrics...\r\n```\r\n\r\nThese metrics are updated throughout the request lifecycle:\r\n\r\n```erlang\r\n% When a connection is established\r\nprometheus_gauge:inc(outbound_connections);\r\n\r\n% When a connection is closed\r\nprometheus_gauge:dec(outbound_connections);\r\n\r\n% When a request completes\r\nprometheus_histogram:observe(http_request_duration_seconds, [\r\n        method_to_list(Method),\r\n        Path,\r\n        get_status_class(Response)\r\n    ], EndTime - StartTime);\r\n    \r\n% For download metrics\r\nprometheus_counter:inc(\r\n    http_client_downloaded_bytes_total,\r\n    [Path],\r\n    byte_size(Data)\r\n);\r\n\r\n% For upload metrics\r\nprometheus_counter:inc(\r\n    http_client_uploaded_bytes_total,\r\n    [Path],\r\n    byte_size(Body)\r\n);\r\n```\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Uses `hb_opts` for configuration options\r\n- Uses `hb_util` for utility functions\r\n\r\n### Integration with Network Communication Subsystem\r\n\r\n- Called by `hb_http` for making outbound HTTP requests\r\n- Works with `hb_http_client_sup` for supervision\r\n\r\n### Integration with Arweave Subsystem\r\n\r\n- Uses `ar_rate_limiter` for request throttling\r\n- Uses `ar_util` for formatting peer addresses",
  "description": "`hb_http_client.erl` implements the client-side component of HyperBEAM's HTTP functionality, managing outbound HTTP connections and requests to external services. This module provides a layer of abstraction over lower-level HTTP client libraries, supporting both `gun` (an Erlang HTTP client based on the BEAM socket interface) and `httpc` (the standard OTP HTTP client).",
  "hasCode": true
}