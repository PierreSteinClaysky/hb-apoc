{
  "name": "`hb_client",
  "subsystem": "network",
  "filename": "hb_client.erl",
  "content": "# `hb_client.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_client.erl` serves as a high-level client interface for HyperBEAM, providing a bridge between the system's internal message-based architecture and remote services. The module enables communication with remote HyperBEAM nodes through the Converge protocol and facilitates integration with Arweave blockchain services for data persistence and timestamping.\r\n\r\nUnlike the lower-level `hb_http_client.erl` which focuses on connection management and HTTP protocol details, this module operates at a higher level of abstraction, dealing with complete message exchanges and protocol-specific operations. It can be seen as a client library for HyperBEAM services, abstracting the complexity of message conversion, signing, and transmission.\r\n\r\nThe module is organized into three major functional areas:\r\n1. Converge API - For message resolution on remote nodes\r\n2. Arweave node API - For accessing blockchain data and timestamps\r\n3. Data upload API - For sending data to Arweave bundlers\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Message Transformation**: Transforms message pairs into singleton requests for remote resolution\r\n- **Key Prefixing**: Adds prefixes to message keys to support resolution contexts\r\n- **Route Management**: Provides functions for retrieving and adding routes\r\n- **Arweave Integration**: Fetches blockchain timestamps and other node information\r\n- **Data Upload**: Supports uploading data in different formats (ANS-104, HTTPSig)\r\n- **Format Conversion**: Handles conversions between different message formats\r\n- **Bundler Selection**: Chooses appropriate bundler services based on message format\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_http`: For making HTTP requests to remote nodes\r\n- `hb_converge`: For message resolution and key operations\r\n- `hb_message`: For message conversion and attestation\r\n- `hb_opts`: For configuration access\r\n- `ar_bundles`: For Arweave bundle serialization/deserialization\r\n- `httpc`: For direct HTTP requests to Arweave nodes\r\n- `jiffy`: For JSON parsing\r\n\r\n\n\n## Implementation Details\r\n\r\n### Converge API\r\n\r\nThe module provides functionality for resolving message pairs on remote nodes through the Converge protocol:\r\n\r\n```erlang\r\nresolve(Node, Msg1, Msg2, Opts) ->\r\n    TABM2 =\r\n        hb_converge:set(\r\n            #{\r\n                <<\"path\">> => hb_converge:get(<<\"path\">>, Msg2, <<\"/\">>, Opts),\r\n                <<\"2.path\">> => unset\r\n            },\r\n        prefix_keys(<<\"2.\">>, Msg2, Opts),\r\n        Opts#{ hashpath => ignore }\r\n    ),\r\n    hb_http:post(\r\n        Node,\r\n        maps:merge(prefix_keys(<<\"1.\">>, Msg1, Opts), TABM2),\r\n        Opts\r\n    ).\r\n```\r\n\r\nThis function:\r\n1. Takes two messages (`Msg1` and `Msg2`)\r\n2. Prefixes the keys in both messages to provide context (`1.` and `2.`)\r\n3. Adjusts the path in `Msg2` to create a properly formed request\r\n4. Merges the two transformed messages\r\n5. Posts the combined message to the specified node\r\n\r\nThe key prefixing is handled by a helper function:\r\n\r\n```erlang\r\nprefix_keys(Prefix, Message, Opts) ->\r\n    maps:fold(\r\n        fun(Key, Val, Acc) ->\r\n            maps:put(<<Prefix/binary, Key/binary>>, Val, Acc)\r\n        end,\r\n        #{},\r\n        hb_message:convert(Message, tabm, Opts)\r\n    ).\r\n```\r\n\r\nThis ensures all keys are properly namespaced when sending multiple messages in a single request.\r\n\r\nThe module also provides convenience functions for route management:\r\n\r\n```erlang\r\nroutes(Node, Opts) ->\r\n    resolve(Node,\r\n        #{\r\n            <<\"device\">> => <<\"Router@1.0\">>\r\n        },\r\n        #{\r\n            <<\"path\">> => <<\"routes\">>,\r\n            <<\"method\">> => <<\"GET\">>\r\n        },\r\n        Opts\r\n    ).\r\n\r\nadd_route(Node, Route, Opts) ->\r\n    resolve(Node,\r\n        Route#{\r\n            <<\"device\">> => <<\"Router@1.0\">>\r\n        },\r\n        #{\r\n            <<\"path\">> => <<\"routes\">>,\r\n            <<\"method\">> => <<\"POST\">>\r\n        },\r\n        Opts\r\n    ).\r\n```\r\n\r\nThese functions interact with a router device on the remote node to manage route configuration.\r\n\r\n### Arweave Node API\r\n\r\nThe module provides a function for accessing Arweave blockchain information:\r\n\r\n```erlang\r\narweave_timestamp() ->\r\n    case hb_opts:get(mode) of\r\n        debug -> {0, 0, <<0:256>>};\r\n        prod ->\r\n            {ok, {{_, 200, _}, _, Body}} =\r\n                httpc:request(\r\n                    <<(hb_opts:get(gateway))/binary, \"/block/current\">>\r\n                ),\r\n            {Fields} = jiffy:decode(Body),\r\n            {_, Timestamp} = lists:keyfind(<<\"timestamp\">>, 1, Fields),\r\n            {_, Hash} = lists:keyfind(<<\"indep_hash\">>, 1, Fields),\r\n            {_, Height} = lists:keyfind(<<\"height\">>, 1, Fields),\r\n            {Timestamp, Height, Hash}\r\n    end.\r\n```\r\n\r\nThis function retrieves the current block information from an Arweave gateway, extracting the timestamp, block height, and hash. It also provides a mock response in debug mode.\r\n\r\n### Data Upload API\r\n\r\nThe module includes sophisticated functionality for uploading data to Arweave bundler nodes:\r\n\r\n```erlang\r\nupload(Msg, Opts) ->\r\n    upload(Msg, Opts, hb_converge:get(<<\"codec-device\">>, Msg, <<\"httpsig@1.0\">>, Opts)).\r\n\r\nupload(Msg, Opts, <<\"httpsig@1.0\">>) ->\r\n    case hb_opts:get(bundler_httpsig, not_found, Opts) of\r\n        not_found ->\r\n            {error, no_httpsig_bundler};\r\n        Bundler ->\r\n            ?event({uploading_item, Msg}),\r\n            hb_http:post(Bundler, <<\"/tx\">>, Msg, Opts)\r\n    end;\r\n\r\nupload(Msg, Opts, <<\"ans104@1.0\">>) when is_map(Msg) ->\r\n    ?event({msg_to_convert, Msg}),\r\n    Converted = hb_message:convert(Msg, <<\"ans104@1.0\">>, Opts),\r\n    ?event({msg_to_tx_res, {converted, Converted}}),\r\n    Serialized = ar_bundles:serialize(Converted),\r\n    ?event({converted_msg_to_tx, Serialized}),\r\n    upload(Serialized, Opts, <<\"ans104@1.0\">>);\r\n\r\nupload(Serialized, Opts, <<\"ans104@1.0\">>) when is_binary(Serialized) ->\r\n    ?event({uploading_item, Serialized}),\r\n    hb_http:post(\r\n        hb_opts:get(bundler_ans104, not_found, Opts),\r\n        #{\r\n            <<\"path\">> => <<\"/tx\">>,\r\n            <<\"content-type\">> => <<\"application/octet-stream\">>,\r\n            <<\"body\">> => Serialized\r\n        },\r\n        Opts#{\r\n            http_client =>\r\n                hb_opts:get(bundler_ans104_http_client, httpc, Opts)\r\n        }\r\n    ).\r\n```\r\n\r\nThis implementation handles different message formats:\r\n1. Determines the codec device from the message or defaults to `httpsig@1.0`\r\n2. For `httpsig@1.0`, looks up the appropriate bundler and posts the message directly\r\n3. For `ans104@1.0` with a map input, converts the message to ANS-104 format, serializes it, and uploads\r\n4. For `ans104@1.0` with binary input, posts directly to the ANS-104 bundler\r\n5. Supports specifying a different HTTP client implementation for different bundlers\r\n\r\n### Tests\r\n\r\nThe module includes several tests that verify its data upload capabilities:\r\n\r\n```erlang\r\nupload_empty_raw_ans104_test() ->\r\n    Serialized = ar_bundles:serialize(\r\n        ar_bundles:sign_item(#tx{\r\n            data = <<\"TEST\">>\r\n        }, hb:wallet())\r\n    ),\r\n    ?event({uploading_item, Serialized}),\r\n    Result = upload(Serialized, #{}, <<\"ans104@1.0\">>),\r\n    ?event({upload_result, Result}),\r\n    ?assertMatch({ok, _}, Result).\r\n```\r\n\r\nThese tests demonstrate different upload scenarios:\r\n- Uploading an empty ANS-104 transaction\r\n- Uploading an ANS-104 transaction with tags\r\n- Uploading an ANS-104 transaction with an anchor\r\n- Uploading a message that gets converted to ANS-104\r\n- Uploading a more complex message with different data types\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Network Communication Subsystem\r\n\r\n- Uses `hb_http` to make HTTP requests to remote nodes and bundlers\r\n- Builds on the lower-level HTTP client implementation\r\n- Handles higher-level protocol concerns above the HTTP layer\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Uses `hb_converge` for message resolution and key operations\r\n- Uses `hb_message` for message conversion and attestation\r\n- Uses `hb_opts` for configuration access\r\n- Leverages the message-centric architecture of the core system\r\n\r\n### Integration with Arweave Subsystem\r\n\r\n- Fetches data from Arweave nodes\r\n- Uploads data to Arweave bundlers\r\n- Uses `ar_bundles` for serialization and deserialization\r\n- Facilitates integration with the Arweave blockchain",
  "description": "`hb_client.erl` serves as a high-level client interface for HyperBEAM, providing a bridge between the system's internal message-based architecture and remote services. The module enables communication with remote HyperBEAM nodes through the Converge protocol and facilitates integration with Arweave blockchain services for data persistence and timestamping.",
  "hasCode": true
}