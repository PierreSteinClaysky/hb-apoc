{
  "name": "`dev_codec_structured",
  "subsystem": "codec",
  "filename": "dev_codec_structured.erl",
  "content": "# `dev_codec_structured.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`dev_codec_structured.erl` implements a codec for HyperBEAM's internal, richly typed message format. This module bridges the gap between Erlang's native data structures and HyperBEAM's Type-Annotated-Binary-Message (TABM) format, which is designed to be similar to HTTP Structured Fields (RFC-9651) but with adaptations for HyperBEAM's specific needs.\r\n\r\nThe module serves as a foundational component of HyperBEAM's message handling system, enabling the system to maintain type information across serialization boundaries. By preserving type information in the serialized format, it ensures that messages can be properly reconstructed with their original types after transmission or storage.\r\n\r\nAs a codec device, it implements the standard `to/1` and `from/1` interface functions required by the Converge protocol. Additionally, it delegates attestation functions to the `dev_codec_httpsig` module, establishing a clean separation of concerns between message format conversion and cryptographic operations.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Type Preservation**: Preserves Erlang type information during serialization and deserialization\r\n- **Recursive Handling**: Processes nested structures (maps, lists) recursively\r\n- **Special Value Handling**: Provides special handling for empty values (empty binaries, lists, maps)\r\n- **RFC Alignment**: Mirrors HTTP Structured Fields format with extensions for HyperBEAM's requirements\r\n- **Typed Message Format**: Uses an `ao-types` field to store type information for non-binary fields\r\n- **Atomic Type Support**: Handles Erlang primitives (atoms, integers, floats, binaries)\r\n- **Compound Type Support**: Processes complex types (lists, maps) with proper type tracking\r\n- **Function Representation**: Provides a binary representation for functions (with runtime limitations)\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_converge`: For key normalization and message resolution\r\n- `hb_structured_fields`: For parsing and serializing HTTP Structured Fields\r\n- `hb_message`: For message filtering\r\n- `hb_path`: For binary conversion\r\n- `hb_private`: For private key filtering\r\n- `hb_util`: For message manipulation utilities\r\n- `dev_codec_httpsig`: For attestation and verification functions\r\n\r\n\n\n## Implementation Details\r\n\r\n### Serialization (from/1)\r\n\r\nThe `from/1` function converts a rich Erlang message into TABM format:\r\n\r\n```erlang\r\nfrom(Msg) when is_map(Msg) ->\r\n    NormKeysMap = hb_converge:normalize_keys(Msg),\r\n    {Types, Values} = lists:foldl(\r\n        fun (Key, {Types, Values}) ->\r\n            case maps:find(Key, NormKeysMap) of\r\n                {ok, <<>>} ->\r\n                    % Handle empty binary\r\n                    BinKey = hb_converge:normalize_key(Key),\r\n                    {[{BinKey, <<\"empty-binary\">>} | Types], Values};\r\n                {ok, []} ->\r\n                    % Handle empty list\r\n                    BinKey = hb_converge:normalize_key(Key),\r\n                    {[{BinKey, <<\"empty-list\">>} | Types], Values};\r\n                {ok, EmptyMap} when ?IS_EMPTY_MESSAGE(EmptyMap) ->\r\n                    % Handle empty map\r\n                    BinKey = hb_converge:normalize_key(Key),\r\n                    {[{BinKey, <<\"empty-message\">>} | Types], Values};\r\n                % ... more cases for different types ...\r\n            end\r\n        end,\r\n        {[], []},\r\n        % Filter certain keys\r\n        lists:filter(\r\n            fun(Key) ->\r\n                not lists:member(Key, ?REGEN_KEYS) andalso\r\n                    not hb_private:is_private(Key)\r\n            end,\r\n            hb_util:to_sorted_keys(NormKeysMap)\r\n        )\r\n    ),\r\n    % ... construct the final message ...\r\n```\r\n\r\nThis function:\r\n1. Normalizes message keys for consistency\r\n2. Filters out private keys and regeneration keys\r\n3. Processes each message field based on its type\r\n4. Accumulates type information and serialized values\r\n5. Combines them into a well-structured TABM\r\n\r\n### Deserialization (to/1)\r\n\r\nThe `to/1` function converts a TABM back to a native Erlang message:\r\n\r\n```erlang\r\nto(TABM0) ->\r\n    Types = case maps:get(<<\"ao-types\">>, TABM0, <<>>) of\r\n        <<>> -> #{};\r\n        Bin -> parse_ao_types(Bin)\r\n    end,\r\n    % Handle empty values\r\n    TABM1 = maps:from_list(\r\n        maps:fold(\r\n            fun (Key, <<\"empty-binary\">>, Acc) -> [{Key, <<>>} | Acc];\r\n                (Key, <<\"empty-list\">>, Acc) -> [{Key, []} | Acc];\r\n                (Key, <<\"empty-message\">>, Acc) -> [{Key, #{}} | Acc];\r\n                (_Key, _Value, Acc) -> Acc\r\n            end,\r\n            [],\r\n            Types\r\n        )\r\n    ),\r\n    % Process the message\r\n    hb_message:filter_default_keys(maps:fold(\r\n        % ... process each field based on type information ...\r\n    ))\r\n```\r\n\r\nThis function:\r\n1. Extracts type information from the `ao-types` field\r\n2. Initializes the result with empty values\r\n3. Processes each field according to its type\r\n4. Handles nested structures recursively\r\n5. Removes default keys for cleaner output\r\n\r\n### Type Encoding/Decoding\r\n\r\nThe module includes specialized functions for encoding and decoding different Erlang types:\r\n\r\n```erlang\r\nencode_value(Value) when is_integer(Value) ->\r\n    [Encoded, _] = hb_structured_fields:item({item, Value, []}),\r\n    {<<\"integer\">>, Encoded};\r\nencode_value(Value) when is_atom(Value) ->\r\n    [EncodedIOList, _] =\r\n        hb_structured_fields:item(\r\n            {item, {string, atom_to_binary(Value, latin1)}, []}),\r\n    Encoded = list_to_binary(EncodedIOList),\r\n    {<<\"atom\">>, Encoded};\r\n% ... more type encoders ...\r\n```\r\n\r\nFor decoding:\r\n\r\n```erlang\r\ndecode_value(integer, Value) ->\r\n    {item, Number, _} = hb_structured_fields:parse_item(Value),\r\n    Number;\r\ndecode_value(atom, Value) ->\r\n    {item, {_, AtomString}, _} =\r\n        hb_structured_fields:parse_item(Value),\r\n    binary_to_existing_atom(AtomString);\r\n% ... more type decoders ...\r\n```\r\n\r\nThese functions handle the specifics of converting each Erlang type to and from its serialized representation.\r\n\r\n### List Handling\r\n\r\nSpecial attention is given to list handling, especially for nested lists:\r\n\r\n```erlang\r\ndecode_value(list, Value) ->\r\n    lists:map(\r\n        fun({item, {string, <<\"(ao-type-\", Rest/binary>>}, _}) ->\r\n            [Type, Item] = binary:split(Rest, <<\") \">>),\r\n            decode_value(Type, Item);\r\n           ({item, Item, _}) -> hb_structured_fields:from_bare_item(Item)\r\n        end,\r\n        hb_structured_fields:parse_list(iolist_to_binary(Value))\r\n    );\r\n```\r\n\r\nThis enables proper handling of heterogeneous lists with different element types.\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Uses `hb_converge` for key normalization and message handling\r\n- Leverages `hb_message` for message processing\r\n- Depends on `hb_path` for path and binary conversions\r\n\r\n### Integration with Network Communication Subsystem\r\n\r\n- Provides serialization capability for messages transmitted over the network\r\n- Works alongside HTTP-related codecs to enable web protocol compatibility\r\n- Supports attestation through integration with `dev_codec_httpsig`\r\n\r\n### Integration with Codec and Data Format Subsystem\r\n\r\n- Serves as a foundational format within the subsystem\r\n- Delegates attestation to `dev_codec_httpsig` for cryptographic operations\r\n- Likely interacts with other codecs for format translation",
  "description": "`dev_codec_structured.erl` implements a codec for HyperBEAM's internal, richly typed message format. This module bridges the gap between Erlang's native data structures and HyperBEAM's Type-Annotated-Binary-Message (TABM) format, which is designed to be similar to HTTP Structured Fields (RFC-9651) but with adaptations for HyperBEAM's specific needs.",
  "hasCode": true
}