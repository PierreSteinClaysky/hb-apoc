{
  "name": "`dev_codec_flat",
  "subsystem": "codec",
  "filename": "dev_codec_flat.erl",
  "content": "# `dev_codec_flat.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`dev_codec_flat.erl` implements a codec that transforms between HyperBEAM's nested Type-Annotated-Binary-Message (TABM) format and a flattened representation where hierarchical structures are encoded using path-based keys. This module provides an elegant solution for working with deeply nested message structures in contexts where a flatter representation is preferable.\r\n\r\nThe flattening process is bidirectional, preserving the complete hierarchical relationships while providing a simplified, path-oriented view of the data. This approach facilitates message transmission, storage, and processing in systems that may have limitations with deeply nested structures.\r\n\r\nAs with other codec modules in the system, it implements the standard `from/1` and `to/1` interface functions required by the Converge protocol, while delegating attestation-related functions to `dev_codec_httpsig.erl`.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Path-Based Flattening**: Converts nested map structures to flat maps with path-based keys\r\n- **Hierarchical Preservation**: Maintains complete hierarchical relationships during conversion\r\n- **Collision Detection**: Identifies and handles path collisions during reconstruction\r\n- **Binary Passthrough**: Provides direct passthrough for binary values\r\n- **Deep Nesting Support**: Handles arbitrarily deep nested structures\r\n- **Path Normalization**: Uses standardized path representation across the system\r\n- **Map Merging**: Intelligently merges maps when integrating values at the same location\r\n- **Serialization Utilities**: Includes supplementary functions for text-based serialization and deserialization\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_path`: For path manipulation and conversion\r\n- `hb_message`: For message matching and conversion\r\n- `dev_codec_httpsig`: For attestation functions\r\n\r\n\n\n## Implementation Details\r\n\r\n### Flattening Process (to/1)\r\n\r\nThe `to/1` function converts a nested TABM into a flat map with path-based keys:\r\n\r\n```erlang\r\nto(Bin) when is_binary(Bin) -> Bin;\r\nto(Map) when is_map(Map) ->\r\n    maps:fold(\r\n        fun(Key, Value, Acc) ->\r\n            case to(Value) of\r\n                SubMap when is_map(SubMap) ->\r\n                    maps:fold(\r\n                        fun(SubKey, SubValue, InnerAcc) ->\r\n                            maps:put(\r\n                                hb_path:to_binary([Key, SubKey]),\r\n                                SubValue,\r\n                                InnerAcc\r\n                            )\r\n                        end,\r\n                        Acc,\r\n                        SubMap\r\n                    );\r\n                SimpleValue ->\r\n                    maps:put(hb_path:to_binary([Key]), SimpleValue, Acc)\r\n            end\r\n        end,\r\n        #{},\r\n        Map\r\n    ).\r\n```\r\n\r\nThe function:\r\n1. Recursively processes each key-value pair in the map\r\n2. For values that are themselves maps, continues recursion and creates composite paths\r\n3. For simple values, creates a simple path entry in the result map\r\n4. Preserves binary values directly without modification\r\n5. Uses `hb_path:to_binary/1` to ensure consistent path formatting\r\n\r\n### Unflattening Process (from/1)\r\n\r\nThe `from/1` function reconstructs a nested TABM from a flat, path-based map:\r\n\r\n```erlang\r\nfrom(Bin) when is_binary(Bin) -> Bin;\r\nfrom(Map) when is_map(Map) ->\r\n    maps:fold(\r\n        fun(Path, Value, Acc) ->\r\n            inject_at_path(hb_path:term_to_path_parts(Path), from(Value), Acc)\r\n        end,\r\n        #{},\r\n        Map\r\n    ).\r\n```\r\n\r\nThis function:\r\n1. Processes each path-value pair in the flat map\r\n2. Converts paths to path parts using `hb_path:term_to_path_parts/1`\r\n3. Recursively constructs the nested structure through the helper function `inject_at_path/3`\r\n4. Handles binaries as direct pass-through values\r\n\r\n### Path Injection Logic\r\n\r\nThe `inject_at_path/3` helper function is responsible for inserting values at the correct location in the nested structure:\r\n\r\n```erlang\r\ninject_at_path([Key], Value, Map) ->\r\n    case maps:get(Key, Map, not_found) of\r\n        not_found ->\r\n            Map#{ Key => Value };\r\n        ExistingMap when is_map(ExistingMap) andalso is_map(Value) ->\r\n            % If both are maps, merge them\r\n            Map#{ Key => maps:merge(ExistingMap, Value) };\r\n        OldValue ->\r\n            % Otherwise, alert the user and fail\r\n            throw({path_collision,\r\n                {key, Key},\r\n                {existing, OldValue},\r\n                {value, Value}\r\n            })\r\n    end;\r\ninject_at_path([Key|Rest], Value, Map) ->\r\n    SubMap = maps:get(Key, Map, #{}),\r\n    maps:put(Key, inject_at_path(Rest, Value, SubMap), Map).\r\n```\r\n\r\nThis function:\r\n1. Handles the base case where there's only one path component left\r\n2. Detects and resolves potential conflicts:\r\n   - For new keys, simply adds the value\r\n   - For existing map keys that receive map values, merges the maps\r\n   - For other collisions, throws a detailed exception\r\n3. For multi-part paths, recursively builds the structure by creating intermediate maps\r\n\r\n### Serialization Utilities\r\n\r\nThe module provides additional utilities for text-based serialization and deserialization:\r\n\r\n```erlang\r\nserialize(Map) when is_map(Map) ->\r\n    Flattened = hb_message:convert(Map, <<\"flat@1.0\">>, #{}),\r\n    {ok,\r\n        iolist_to_binary(lists:foldl(\r\n                fun(Key, Acc) ->\r\n                    [\r\n                        Acc,\r\n                        hb_path:to_binary(Key),\r\n                        <<\": \">>,\r\n                        maps:get(Key, Flattened), <<\"\\n\">>\r\n                    ]\r\n                end,\r\n                <<>>,\r\n                maps:keys(Flattened)\r\n            )\r\n        )\r\n    }.\r\n\r\ndeserialize(Bin) when is_binary(Bin) ->\r\n    Flat = lists:foldl(\r\n        fun(Line, Acc) ->\r\n            case binary:split(Line, <<\": \">>, [global]) of\r\n                [Key, Value] ->\r\n                    Acc#{ Key => Value };\r\n                _ ->\r\n                    Acc\r\n            end\r\n        end,\r\n        #{},\r\n        binary:split(Bin, <<\"\\n\">>, [global])\r\n    ),\r\n    {ok, hb_message:convert(Flat, <<\"structured@1.0\">>, <<\"flat@1.0\">>, #{})}.\r\n```\r\n\r\nThese functions:\r\n1. Convert between maps and a simple text-based format with \"key: value\" lines\r\n2. Leverage the system's message conversion infrastructure\r\n3. Provide a human-readable representation for debugging and lightweight interchange\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Codec and Data Format Subsystem\r\n\r\n- Provides a fundamental encoding transformation that other codecs can leverage\r\n- Works in conjunction with `dev_codec_httpsig` for attestation functionality\r\n- Follows the standard codec interface pattern established throughout the subsystem\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Uses `hb_path` for standardized path manipulation\r\n- Leverages `hb_message` for message conversion and matching\r\n- Adheres to the TABM format conventions used throughout the system\r\n\r\n### Integration with Storage Subsystem\r\n\r\nWhile not directly connected, the flat format is particularly well-suited for:\r\n- Storage systems that work better with flat key-value pairs\r\n- Database systems with hierarchical path indexing capabilities\r\n- Serialization formats where nested structure incurs overhead",
  "description": "`dev_codec_flat.erl` implements a codec that transforms between HyperBEAM's nested Type-Annotated-Binary-Message (TABM) format and a flattened representation where hierarchical structures are encoded using path-based keys. This module provides an elegant solution for working with deeply nested message structures in contexts where a flatter representation is preferable.",
  "hasCode": true
}