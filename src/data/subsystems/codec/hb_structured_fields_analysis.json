{
  "name": "`hb_structured_fields",
  "subsystem": "codec",
  "filename": "hb_structured_fields.erl",
  "content": "# `hb_structured_fields.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_structured_fields.erl` implements parsing and serialization functionality for HTTP Structured Fields as described in RFC-9651. This module serves as a foundational library for working with structured data in HTTP headers, providing a comprehensive conversion layer between Erlang data structures and standardized HTTP header formats.\r\n\r\nThe module supports all data types defined in the RFC, including items, lists, dictionaries, and their associated parameterization, enabling HyperBEAM to correctly process and generate HTTP headers that adhere to the Structured Fields specification. This capability is crucial for interoperability with HTTP-based systems, especially those that leverage newer HTTP standards.\r\n\r\nBy providing both parsing (deserialization) and generation (serialization) functions, the module creates a complete bidirectional bridge between HyperBEAM's internal representation and standard HTTP header formats.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **RFC-9651 Compliant**: Full implementation of the HTTP Structured Fields specification\r\n- **Bidirectional Conversion**: Supports both parsing and serialization operations\r\n- **Type Mapping**: Clear mapping between Erlang types and structured header types\r\n- **Comprehensive Type Support**: Handles integers, decimals, strings, tokens, byte sequences, and booleans\r\n- **Parameter Support**: Manages parameters attached to items and inner lists\r\n- **Defensive Parsing**: Robust error handling for malformed input\r\n- **Strict Validation**: Enforces format constraints during serialization\r\n- **Optimized Decimal Handling**: Special handling for various decimal precision cases\r\n- **Extensive Testing**: Includes property-based and conformance tests against reference implementations\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- **Base64**: Erlang/OTP's base64 module for binary encoding/decoding\r\n- **JSX**: For JSON processing in test cases\r\n- **Eunit**: For testing infrastructure\r\n- **Base32**: For binary decoding in test cases\r\n\r\n\n\n## Implementation Details\r\n\r\n### Type Representation\r\n\r\nThe module uses a clear mapping between Erlang types and HTTP Structured Fields:\r\n\r\n```erlang\r\n-type sh_list() :: [sh_item() | sh_inner_list()].\r\n-type sh_inner_list() :: {list, [sh_item()], sh_params()}.\r\n-type sh_params() :: [{binary(), sh_bare_item()}].\r\n-type sh_dictionary() :: [{binary(), sh_item() | sh_inner_list()}].\r\n-type sh_item() :: {item, sh_bare_item(), sh_params()}.\r\n-type sh_bare_item() ::\r\n    integer()\r\n    | sh_decimal()\r\n    | boolean()\r\n    | {string | token | binary, binary()}.\r\n-type sh_decimal() :: {decimal, {integer(), integer()}}.\r\n```\r\n\r\nThis type system allows for precise representation of all structured field types while maintaining Erlang's strong typing.\r\n\r\n### Parsing Functions\r\n\r\nThe module provides separate parsing functions for each Structured Fields type:\r\n\r\n#### Dictionary Parsing\r\n\r\n```erlang\r\nparse_dictionary(<<>>) ->\r\n    [];\r\nparse_dictionary(<<C, R/bits>>) when ?IS_LC_ALPHA(C) or ?IS_DIGIT(C) or (C =:= $*) ->\r\n    parse_dict_key(R, [], <<C>>).\r\n```\r\n\r\nThis recursively parses dictionaries with keys and values, handling parameters and managing whitespace.\r\n\r\n#### Item Parsing\r\n\r\n```erlang\r\nparse_item(Bin) ->\r\n    {Item, <<>>} = parse_item1(Bin),\r\n    Item.\r\n\r\nparse_item1(Bin) ->\r\n    case parse_bare_item(Bin) of\r\n        {Item, <<$;, R/bits>>} ->\r\n            {Params, Rest} = parse_before_param(R, []),\r\n            {{item, Item, Params}, Rest};\r\n        {Item, Rest} ->\r\n            {{item, Item, []}, Rest}\r\n    end.\r\n```\r\n\r\nThis handles the parsing of individual items with their parameters.\r\n\r\n#### List Parsing\r\n\r\n```erlang\r\nparse_list(<<>>) ->\r\n    [];\r\nparse_list(Bin) ->\r\n    parse_list_before_member(Bin, []).\r\n```\r\n\r\nThis parses lists of items with careful attention to inner lists and parameters.\r\n\r\n#### Bare Item Parsing\r\n\r\n```erlang\r\nparse_bare_item(<<$-, R/bits>>) -> parse_number(R, 0, <<$->>);\r\nparse_bare_item(<<C, R/bits>>) when ?IS_DIGIT(C) -> parse_number(R, 1, <<C>>);\r\nparse_bare_item(<<$\", R/bits>>) -> parse_string(R, <<>>);\r\n% ... other cases for tokens, byte sequences, booleans, etc.\r\n```\r\n\r\nThis forms the foundation of parsing atomic values like numbers, strings, tokens, etc.\r\n\r\n### Serialization Functions\r\n\r\nThe module includes corresponding functions for serializing Erlang data to HTTP Structured Fields format:\r\n\r\n#### Dictionary Serialization\r\n\r\n```erlang\r\ndictionary(Map) when is_map(Map) ->\r\n    dictionary(maps:to_list(Map));\r\ndictionary(KVList) when is_list(KVList) ->\r\n    lists:join(<<\", \">>, [\r\n        case Value of\r\n            true -> Key;\r\n            _ -> [Key, $=, item_or_inner_list(Value)]\r\n        end\r\n    || {Key, Value} <- KVList\r\n    ]).\r\n```\r\n\r\nThis converts a map or key-value list to a structured dictionary format.\r\n\r\n#### Item Serialization\r\n\r\n```erlang\r\nitem({item, BareItem, Params}) ->\r\n    [bare_item(BareItem), params(Params)].\r\n```\r\n\r\nThis serializes an item with its parameters.\r\n\r\n#### List Serialization\r\n\r\n```erlang\r\nlist(List) ->\r\n    lists:join(<<\", \">>, [item_or_inner_list(Value) || Value <- List]).\r\n```\r\n\r\nThis converts a list of items to its structured field representation.\r\n\r\n#### Bare Item Serialization\r\n\r\n```erlang\r\nbare_item({string, String}) ->\r\n    [$\", escape_string(String, <<>>), $\"];\r\nbare_item({token, Token}) ->\r\n    Token;\r\n% ... other cases for different types\r\n```\r\n\r\nThis handles the serialization of primitive values like strings, tokens, numbers, etc.\r\n\r\n### Conversion Utilities\r\n\r\nThe module also provides utilities for converting Erlang values to structured field representations:\r\n\r\n```erlang\r\nto_dictionary(Map) when is_map(Map) ->\r\n   to_dictionary(maps:to_list(Map));\r\nto_dictionary(Pairs) when is_list(Pairs) ->\r\n    to_dictionary([], Pairs).\r\n\r\nto_item(Item) ->\r\n    to_item(Item, []).\r\n```\r\n\r\nThese functions allow for easy conversion of Erlang data structures to their structured field equivalents.\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Network Communication Subsystem\r\n\r\n- Provides parsing and generation of HTTP headers for the HTTP server and client\r\n- Enables correct handling of structured field headers in HTTP requests and responses\r\n- Supports advanced HTTP features that rely on structured fields\r\n\r\n### Integration with Codec and Data Format Subsystem\r\n\r\n- Forms the foundation for type-safe serialization in various codecs\r\n- Works with `dev_codec_structured` and `dev_codec_httpsig` for message format conversion\r\n- Enables interconversion between internal message formats and HTTP headers\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Supports message format conversion through the `hb_message` module\r\n- Provides standardized format handling for various parts of the system\r\n- Enables cryptographic verification through structured field parameter handling",
  "description": "`hb_structured_fields.erl` implements parsing and serialization functionality for HTTP Structured Fields as described in RFC-9651. This module serves as a foundational library for working with structured data in HTTP headers, providing a comprehensive conversion layer between Erlang data structures and standardized HTTP header formats.",
  "hasCode": true
}