{
  "name": "`dev_codec_httpsig_conv",
  "subsystem": "codec",
  "filename": "dev_codec_httpsig_conv.erl",
  "content": "# `dev_codec_httpsig_conv.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`dev_codec_httpsig_conv.erl` implements a specialized codec that marshals messages between HyperBEAM's internal Type-Annotated-Binary-Message (TABM) format and HTTP message structures. This module handles the complex task of transforming between HyperBEAM's rich data model and the constraints of HTTP's wire format, with particular attention to preserving type information, handling nested structures, and maintaining cryptographic attestations.\r\n\r\nThe module serves as the implementation companion to `dev_codec_httpsig.erl`, which provides the primary interface. While `dev_codec_httpsig.erl` focuses on HTTP Message Signatures and attestation operations, this module performs the actual conversion logic, managing the transformation of data between formats in a way that preserves hierarchical relationships and security properties.\r\n\r\nA key feature of this module is its use of HTTP multipart messages as defined in RFC-7578, which enables it to handle complex nested message structures and large message values that exceed HTTP header size limitations.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **HTTP Multipart Support**: Uses the multipart/form-data format to encode complex message structures\r\n- **Adaptive Field Placement**: Intelligently places message fields in either HTTP headers or body parts based on size constraints\r\n- **Nested Structure Preservation**: Maintains hierarchical relationships between message components\r\n- **Signature Integration**: Seamlessly extracts and embeds HTTP Message Signatures during conversion\r\n- **Protocol Compliance**: Follows HTTP standards for multipart encoding and header formats\r\n- **Content-Disposition Handling**: Uses Content-Disposition headers to identify field types and relationships\r\n- **Size-Aware Processing**: Adjusts encoding strategies based on field sizes and HTTP limitations\r\n- **Body Part Management**: Special handling for the main message body with inline fields\r\n- **Hashpath Preservation**: Maintains cryptographic hashpaths across conversion boundaries\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `dev_codec_httpsig`: For attestation handling and signature operations\r\n- `dev_codec_flat`: For message flattening and restoration\r\n- `hb_structured_fields`: For parsing and formatting HTTP Structured Fields\r\n- `hb_converge`: For key normalization and message resolution\r\n- `hb_util`: For cryptographic operations and utility functions\r\n- `ar_wallet`: For cryptographic address calculation\r\n\r\n\n\n## Implementation Details\r\n\r\n### Message Conversion: TABM to HTTP (to/1)\r\n\r\nThe `to/1` function converts a TABM message into an HTTP message structure:\r\n\r\n```erlang\r\nto(TABM) -> to(TABM, []).\r\nto(TABM, Opts) when is_map(TABM) ->\r\n    Stripped = maps:without(\r\n        [<<\"attestations\">>, <<\"signature\">>, <<\"signature-input\">>, <<\"priv\">>],\r\n        TABM\r\n    ),\r\n    {InlineFieldHdrs, InlineKey} = inline_key(TABM),\r\n    Intermediate = do_to(Stripped, Opts ++ [{inline, InlineFieldHdrs, InlineKey}]),\r\n    % Add signatures if present\r\n    case maps:get(<<\"attestations\">>, TABM, not_found) of\r\n        #{ <<\"hmac-sha256\">> := #{ <<\"signature\">> := Sig, <<\"signature-input\">> := SigInput } } ->\r\n            HPs = hashpaths_from_message(TABM),\r\n            EncWithHPs = maps:merge(Intermediate, HPs),\r\n            Res = EncWithHPs#{\r\n                <<\"signature\">> => Sig,\r\n                <<\"signature-input\">> => SigInput\r\n            },\r\n            Res;\r\n        _ -> Intermediate\r\n    end.\r\n```\r\n\r\nThe implementation:\r\n1. Strips attestation and private fields from the message\r\n2. Determines the inline body key for the message\r\n3. Processes the message body and transforms it to HTTP format\r\n4. Adds signatures and hashpaths if present\r\n\r\n### Message Conversion: HTTP to TABM (from/1)\r\n\r\nThe `from/1` function converts an HTTP message into a TABM:\r\n\r\n```erlang\r\nfrom(HTTP) ->\r\n    Body = maps:get(<<\"body\">>, HTTP, <<>>),\r\n    {_, InlinedKey} = inline_key(HTTP),\r\n    Headers = maps:without([<<\"body\">>, <<\"body-keys\">>], HTTP),\r\n    ContentType = maps:get(<<\"content-type\">>, Headers, undefined),\r\n    MsgWithoutSigs = maps:without(\r\n        [<<\"signature\">>, <<\"signature-input\">>, <<\"attestations\">>],\r\n        from_body(Headers, InlinedKey, ContentType, Body)\r\n    ),\r\n    HPs = extract_hashpaths(HTTP),\r\n    {ok, MsgWithSigs} = attestations_from_signature(\r\n        maps:without(maps:keys(HPs), MsgWithoutSigs),\r\n        HPs,\r\n        maps:get(<<\"signature\">>, Headers, not_found),\r\n        maps:get(<<\"signature-input\">>, Headers, not_found)\r\n    ),\r\n    maps:without(maps:keys(HPs) ++ [<<\"content-digest\">>], MsgWithSigs)\r\n```\r\n\r\nThis function:\r\n1. Extracts the body and content type from the HTTP message\r\n2. Determines the inline body key for the message\r\n3. Processes the body content, potentially parsing multipart structures\r\n4. Extracts hashpaths from the message\r\n5. Builds attestations from signatures and signature inputs\r\n6. Removes temporary fields from the final message\r\n\r\n### Multipart Body Handling\r\n\r\nA significant part of the implementation deals with HTTP multipart message handling:\r\n\r\n```erlang\r\nfrom_body(TABM, _InlinedKey, _ContentType, <<>>) -> TABM;\r\nfrom_body(TABM, InlinedKey, ContentType, Body) ->\r\n    Params = case ContentType of\r\n        undefined -> [];\r\n        _ ->\r\n            {item, {_, _XT}, XParams} = hb_structured_fields:parse_item(ContentType),\r\n            XParams\r\n    end,\r\n    case lists:keyfind(<<\"boundary\">>, 1, Params) of\r\n        false ->\r\n            % Not multipart, just add body to the inlined key\r\n            maps:put(InlinedKey, Body, TABM);\r\n        {_, {_Type, Boundary}} ->\r\n            % Parse the multipart body\r\n            BegPat = <<\"--\", Boundary/binary, ?CRLF/binary>>,\r\n            EndPat = <<?CRLF/binary, \"--\", Boundary/binary, \"--\">>,\r\n            {Start, SL} = binary:match(Body, BegPat),\r\n            {End, _} = binary:match(Body, EndPat),\r\n            BodyPart = binary:part(Body, Start + SL, End - (Start + SL)),\r\n            Parts = binary:split(BodyPart, [<<?CRLF/binary, \"--\", Boundary/binary>>], [global]),\r\n            {ok, GroupedTABM} = from_body_parts(TABM, InlinedKey, Parts),\r\n            dev_codec_flat:from(GroupedTABM)\r\n    end.\r\n```\r\n\r\nThis code:\r\n1. Handles empty bodies by returning the unchanged TABM\r\n2. For non-multipart bodies, adds the body to the inlined key\r\n3. For multipart bodies, extracts the boundary and parts\r\n4. Parses each part individually and reconstructs the message structure\r\n\r\n### Map Grouping Strategy\r\n\r\nThe module uses a smart grouping strategy to maintain hierarchical relationships:\r\n\r\n```erlang\r\ngroup_maps(Map, Parent, Top) when is_map(Map) ->\r\n    {Flattened, NewTop} = maps:fold(\r\n        fun(Key, Value, {CurMap, CurTop}) ->\r\n            NormKey = hb_converge:normalize_key(Key),\r\n            FlatK = case Parent of\r\n                <<>> -> NormKey;\r\n                _ -> <<Parent/binary, \"/\", NormKey/binary>>\r\n            end,\r\n            case Value of\r\n                _ when is_map(Value) ->\r\n                    NewTop = group_maps(Value, FlatK, CurTop),\r\n                    {CurMap, NewTop};\r\n                _ ->\r\n                    case byte_size(Value) > ?MAX_HEADER_LENGTH of\r\n                        true ->\r\n                            NewTop = maps:put(FlatK, Value, CurTop),\r\n                            {CurMap, CurTop};\r\n                        false ->\r\n                            NewCurMap = maps:put(NormKey, Value, CurMap),\r\n                            {NewCurMap, CurTop}\r\n                    end\r\n            end\r\n        end,\r\n        {#{}, Top},\r\n        Map\r\n    ),\r\n    % Combine results based on context\r\n    case maps:size(Flattened) of\r\n        0 -> NewTop;\r\n        _ -> case Parent of\r\n            <<>> -> maps:merge(NewTop, Flattened);\r\n            _ -> NewTop#{ Parent => Flattened }\r\n        end\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Traverses the map structure recursively\r\n2. Builds path-based keys for nested structures\r\n3. Decides whether to place values in headers or the body based on size\r\n4. Preserves the hierarchical relationship through path encoding\r\n\r\n### Signature and Attestation Handling\r\n\r\nThe module carefully extracts and embeds signature information:\r\n\r\n```erlang\r\nattestations_from_signature(Map, HPs, RawSig, RawSigInput) ->\r\n    SfSigsKV = hb_structured_fields:parse_dictionary(RawSig),\r\n    SfInputs = maps:from_list(hb_structured_fields:parse_dictionary(RawSigInput)),\r\n    Attestations = maps:from_list(lists:map(\r\n        fun ({SigName, Signature}) ->\r\n            {list, SigInputs, ParamsKVList} = maps:get(SigName, SfInputs, #{}),\r\n            % Find hashpaths from signature\r\n            Hashpath = lists:filtermap(\r\n                fun ({item, BareItem, _}) ->\r\n                    case hb_structured_fields:from_bare_item(BareItem) of\r\n                        HP = <<\"hash\", _/binary>> -> {true, HP};\r\n                        _ -> false\r\n                    end;\r\n                (_) -> false\r\n                end,\r\n                SigInputs\r\n            ),\r\n            Hashpaths = maps:from_list(lists:map(\r\n                fun (HP) -> {HP, maps:get(HP, HPs, <<>>)} end,\r\n                Hashpath\r\n            )),\r\n            Params = maps:from_list(ParamsKVList),\r\n            {string, EncPubKey} = maps:get(<<\"keyid\">>, Params),\r\n            PubKey = hb_util:decode(EncPubKey),\r\n            Address = hb_util:human_id(ar_wallet:to_address(PubKey)),\r\n            SerializedSig = iolist_to_binary(\r\n                hb_structured_fields:dictionary(#{ SigName => Signature })\r\n            ),\r\n            {item, {binary, UnencodedSig}, _} = Signature,\r\n            {Address, Hashpaths#{\r\n                <<\"signature\">> => SerializedSig,\r\n                <<\"signature-input\">> => iolist_to_binary(\r\n                    hb_structured_fields:dictionary(\r\n                        #{ SigName => maps:get(SigName, SfInputs) }\r\n                    )\r\n                ),\r\n                <<\"id\">> => hb_util:human_id(crypto:hash(sha256, UnencodedSig)),\r\n                <<\"attestation-device\">> => <<\"httpsig@1.0\">>\r\n            }}\r\n        end,\r\n        SfSigsKV\r\n    )),\r\n    Msg = Map#{ <<\"attestations\">> => Attestations },\r\n    % Reset HMAC if necessary\r\n    case maps:get(<<\"hmac-sha256\">>, Attestations, not_found) of\r\n        not_found -> dev_codec_httpsig:reset_hmac(Msg);\r\n        _ -> Msg\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Parses the signature and signature input fields\r\n2. Extracts relevant hashpaths from the message\r\n3. Identifies the signer's address from the public key\r\n4. Builds structured attestations with necessary metadata\r\n5. Ensures the message HMAC is properly maintained\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Network Communication Subsystem\r\n\r\n- Provides the format bridge between HyperBEAM's internal message format and HTTP wire format\r\n- Enables HTTP servers and clients to work with HyperBEAM's message model\r\n- Supports proper handling of HTTP headers, multipart bodies, and content types\r\n\r\n### Integration with Codec and Data Format Subsystem\r\n\r\n- Works closely with `dev_codec_httpsig.erl` to provide a complete HTTP message handling solution\r\n- Leverages `hb_structured_fields.erl` for structured field parsing and generation\r\n- Uses `dev_codec_flat.erl` for handling nested message structures\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Supports the attestation model through signature extraction and embedding\r\n- Maintains cryptographic properties across format boundaries\r\n- Preserves message relationships through hierarchical path encoding",
  "description": "`dev_codec_httpsig_conv.erl` implements a specialized codec that marshals messages between HyperBEAM's internal Type-Annotated-Binary-Message (TABM) format and HTTP message structures. This module handles the complex task of transforming between HyperBEAM's rich data model and the constraints of HTTP's wire format, with particular attention to preserving type information, handling nested structures, and maintaining cryptographic attestations.",
  "hasCode": true
}