{
  "name": "`hb_store_fs",
  "subsystem": "storage",
  "filename": "hb_store_fs.erl",
  "content": "# `hb_store_fs.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_store_fs.erl` is a filesystem-based implementation of the `hb_store` behavior, providing storage services through the local filesystem. It maps abstract storage operations defined in the `hb_store` behavior to concrete filesystem operations, demonstrating how HyperBEAM's storage abstraction layer works in practice.\r\n\r\nThis implementation uses the filesystem's native directory structure and symbolic links to represent the hierarchical path and link concepts defined in the HyperBEAM storage abstraction.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Filesystem Mapping**: Maps abstract storage operations to filesystem operations\r\n- **Symbolic Link Support**: Uses filesystem symbolic links to implement the storage links concept\r\n- **Hierarchical Structure**: Maps \"groups\" to filesystem directories\r\n- **Path Prefixing**: Prefixes all paths with a configured directory to isolate storage\r\n- **Local Scoping**: Defines itself as having \"local\" scope in the storage ecosystem\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_store`: Implements the behavior defined by this module\r\n- `kernel/include/file.hrl`: Includes file information record definitions\r\n- `include/hb.hrl`: System-wide macros and definitions\r\n- `filelib`: Used for ensuring directories exist and other filesystem utilities\r\n- `file`: Used for fundamental file operations\r\n- `os`: Used for command execution (specifically for `reset` operation)\r\n- `hb_util`: Used for path manipulation (specifically `remove_common`)\r\n- `hb_path`: Used for path component manipulation\r\n\r\n\n\n## Implementation Details\r\n\r\n### Configuration\r\n\r\nThe module is configured through a map with a `<<\"prefix\">>` key that specifies the base directory for all storage operations:\r\n\r\n```erlang\r\n#{ <<\"prefix\">> := DataDir }\r\n```\r\n\r\n### Initialization and Management\r\n\r\n```erlang\r\nstart(#{ <<\"prefix\">> := DataDir }) ->\r\n    ok = filelib:ensure_dir(DataDir).\r\n\r\nstop(#{ <<\"prefix\">> := _DataDir }) ->\r\n    ok.\r\n\r\nscope(_) -> local.\r\n\r\nreset(#{ <<\"prefix\">> := DataDir }) ->\r\n    os:cmd(binary_to_list(<< \"rm -Rf \", DataDir/binary >>)),\r\n    ?event({reset_store, {path, DataDir}}).\r\n```\r\n\r\nThe initialization is straightforward, ensuring the base directory exists. The `reset` operation is more aggressive, using a shell command to completely remove and recreate the directory.\r\n\r\n### Core Storage Operations\r\n\r\n#### Reading\r\n\r\n```erlang\r\nread(Opts, Key) ->\r\n    read(add_prefix(Opts, resolve(Opts, Key))).\r\nread(Path) ->\r\n    ?event({read, Path}),\r\n    case file:read_file_info(Path) of\r\n        {ok, #file_info{type = regular}} ->\r\n            {ok, _} = file:read_file(Path);\r\n        _ ->\r\n            case file:read_link(Path) of\r\n                {ok, Link} ->\r\n                    ?event({link_found, Path, Link}),\r\n                    read(Link);\r\n                _ ->\r\n                    not_found\r\n            end\r\n    end.\r\n```\r\n\r\nReading first resolves the path (following any links) and then reads the file contents. If the target is a symlink, it follows the link recursively.\r\n\r\n#### Writing\r\n\r\n```erlang\r\nwrite(Opts, PathComponents, Value) ->\r\n    Path = add_prefix(Opts, PathComponents),\r\n    ?event({writing, Path, byte_size(Value)}),\r\n    filelib:ensure_dir(Path),\r\n    ok = file:write_file(Path, Value).\r\n```\r\n\r\nWriting ensures the parent directory exists and then writes the binary content to the file.\r\n\r\n#### Listing\r\n\r\n```erlang\r\nlist(Opts, Path) ->\r\n    file:list_dir(add_prefix(Opts, Path)).\r\n```\r\n\r\nListing is a simple pass-through to the filesystem's directory listing functionality.\r\n\r\n### Path Resolution and Manipulation\r\n\r\nThe implementation includes a sophisticated path resolution mechanism that handles symbolic links at different levels of the path:\r\n\r\n```erlang\r\nresolve(Opts, RawPath) ->\r\n    Res = resolve(Opts, \"\", hb_path:term_to_path_parts(hb_store:join(RawPath))),\r\n    ?event({resolved, RawPath, Res}),\r\n    Res.\r\nresolve(_, CurrPath, []) ->\r\n    hb_store:join(CurrPath);\r\nresolve(Opts, CurrPath, [Next|Rest]) ->\r\n    PathPart = hb_store:join([CurrPath, Next]),\r\n    ?event(\r\n        {resolving,\r\n            {accumulated_path, CurrPath},\r\n            {next_segment, Next},\r\n            {generated_partial_path_to_test, PathPart}\r\n        }\r\n    ),\r\n    case file:read_link(add_prefix(Opts, PathPart)) of\r\n        {ok, RawLink} ->\r\n            Link = remove_prefix(Opts, RawLink),\r\n            resolve(Opts, Link, Rest);\r\n        _ ->\r\n            resolve(Opts, PathPart, Rest)\r\n    end.\r\n```\r\n\r\nThis recursive approach resolves each segment of the path in sequence, following any symbolic links encountered along the way. This allows for complex hierarchical structures with links at different levels.\r\n\r\n### Structural Operations\r\n\r\n```erlang\r\nmake_group(Opts = #{ <<\"prefix\">> := _DataDir }, Path) ->\r\n    P = add_prefix(Opts, Path),\r\n    ?event({making_group, P}),\r\n    filelib:ensure_dir(P),\r\n   case file:make_dir(P) of\r\n        ok -> ok;\r\n        {error, eexist} -> ok\r\n    end.\r\n\r\nmake_link(_, Link, Link) -> ok;\r\nmake_link(Opts, Existing, New) ->\r\n    ?event({symlink,\r\n        add_prefix(Opts, Existing),\r\n        P2 = add_prefix(Opts, New)}),\r\n    filelib:ensure_dir(P2),\r\n    file:make_symlink(\r\n        add_prefix(Opts, Existing),\r\n        add_prefix(Opts, New)\r\n    ).\r\n```\r\n\r\nGroups are implemented as directories, and links are implemented as filesystem symbolic links.\r\n\r\n### Path Prefixing\r\n\r\n```erlang\r\nadd_prefix(#{ <<\"prefix\">> := Prefix }, Path) ->\r\n    hb_store:join([Prefix, Path]).\r\n\r\nremove_prefix(#{ <<\"prefix\">> := Prefix }, Path) ->\r\n    hb_util:remove_common(Path, Prefix).\r\n```\r\n\r\nThese helper functions add or remove the storage prefix from paths. This isolation mechanism ensures that the storage system can't access files outside its designated area.\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Storage Abstraction\r\n\r\nAs an implementation of the `hb_store` behavior, this module seamlessly integrates with the storage abstraction layer. Any system component that uses the storage system can transparently use the filesystem implementation without specific knowledge of its inner workings.\r\n\r\n### Integration with Path System\r\n\r\nThe implementation makes extensive use of the path manipulation utilities from `hb_store` and `hb_path`, showing how these subsystems work together to provide a cohesive storage solution.",
  "description": "`hb_store_fs.erl` is a filesystem-based implementation of the `hb_store` behavior, providing storage services through the local filesystem. It maps abstract storage operations defined in the `hb_store` behavior to concrete filesystem operations, demonstrating how HyperBEAM's storage abstraction layer works in practice.",
  "hasCode": true
}