{
  "name": "hb_cache",
  "subsystem": "storage",
  "filename": "hb_cache.erl",
  "content": "# `hb_cache.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_cache.erl` is a sophisticated caching and persistence layer for Converge Protocol messages and compute results in HyperBEAM. The module provides an intelligent storage system that automatically handles content deduplication, attestation linking, and hierarchical data structures, all while leveraging the underlying storage backends provided by the `hb_store` abstraction.\r\n\r\nThis module sits at a higher abstraction level than the raw storage implementations, providing domain-specific storage patterns optimized for the Converge Protocol's message format and attestation mechanisms. It essentially acts as a content-addressed store with specialized handling for cryptographic attestations and hierarchical data.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Content-Addressed Storage**: Stores data at locations derived from cryptographic hashes of the content\r\n- **Multi-Layer Architecture**: Implements three distinct storage layers (raw data, hashpath graph, and message IDs)\r\n- **Automatic Deduplication**: Stores identical content only once through the hashpath system\r\n- **Attestation Management**: Preserves attestation relationships while enabling access through both attested and unattested IDs\r\n- **Deep Structure Support**: Handles arbitrarily nested message structures with full attestation preservation\r\n- **Format Conversion**: Transforms between different message representations (structured, tabm) during storage operations\r\n- **Circular Reference Protection**: Guards against infinite recursion from circular references in the data model\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_store`: For underlying storage operations across different backends\r\n- `hb_path`: For hashpath generation and path manipulation\r\n- `hb_message`: For message conversions and attestation handling\r\n- `hb_private`: For internal message structure manipulation\r\n- `dev_message`: For message ID calculation\r\n- `dev_codec_structured`: For format conversions\r\n- `hb_opts`: For configuration access\r\n- `include/hb.hrl`: System-wide macros and definitions\r\n\r\n\n\n## Implementation Details\r\n\r\n### Storage Architecture\r\n\r\nThe module documentation describes a three-layer architecture for data storage:\r\n\r\n```text\r\n1. The raw binary data, written to the store at the hash of the content.\r\n   Storing binary paths in this way effectively deduplicates the data.\r\n2. The hashpath-graph of all content, stored as a set of links between\r\n   hashpaths, their keys, and the data that underlies them. This allows\r\n   all messages to share the same hashpath space, such that all requests\r\n   from users additively fill-in the hashpath space, minimizing duplicated\r\n   compute.\r\n3. Messages, referrable by their IDs (attested or unattested). These are\r\n   stored as a set of links attestation IDs and the unattested message.\r\n```\r\n\r\nThis layered approach provides both efficient storage and flexible access patterns.\r\n\r\n### Message Writing\r\n\r\nThe core writing function demonstrates the sophisticated handling of messages:\r\n\r\n```erlang\r\nwrite(RawMsg, Opts) ->\r\n    % Use the _structured_ format for calculating alternative IDs, but the\r\n    % _tabm_ format for writing to the store.\r\n    case hb_message:with_only_attested(RawMsg, Opts) of\r\n        {ok, Msg} ->\r\n            AltIDs = calculate_alt_ids(RawMsg, Opts),\r\n            ?event({writing_full_message, {alt_ids, AltIDs}, {msg, Msg}}),\r\n            Tabm = hb_message:convert(Msg, tabm, <<\"structured@1.0\">>, Opts),\r\n            ?event({tabm, Tabm}),\r\n            do_write_message(\r\n                Tabm,\r\n                AltIDs,\r\n                hb_opts:get(store, no_viable_store, Opts),\r\n                Opts\r\n            );\r\n        {error, Err} ->\r\n            {error, Err}\r\n    end.\r\n```\r\n\r\nThe function:\r\n1. Extracts only the attested portions of the message\r\n2. Calculates alternative IDs for different attestations\r\n3. Converts the message to TABM (Type-Annotated Binary Message) format\r\n4. Calls the internal writing function with the prepared data\r\n\r\n### Recursive Message Storage\r\n\r\nFor map-type messages, the system recursively processes each key-value pair:\r\n\r\n```erlang\r\ndo_write_message(Msg, AltIDs, Store, Opts) when is_map(Msg) ->\r\n    % Get the ID of the unsigned message.\r\n    {ok, UnattestedID} = dev_message:id(Msg, #{ <<\"attestors\">> => <<\"none\">> }, Opts),\r\n    ?event({writing_message_with_unsigned_id, UnattestedID, {alts, AltIDs}}),\r\n    MsgHashpathAlg = hb_path:hashpath_alg(Msg),\r\n    hb_store:make_group(Store, UnattestedID),\r\n    % Write the keys of the message into the store...\r\n    maps:map(\r\n        fun(<<\"device\">>, Map) when is_map(Map) ->\r\n            ?event(error, {request_to_write_device_map, {id, hb_message:id(Map)}}),\r\n            throw({device_map_cannot_be_written, {id, hb_message:id(Map)}});\r\n        (Key, Value) ->\r\n            % ... (implementation details) ...\r\n            {ok, Path} = do_write_message(Value, [], Store, Opts),\r\n            hb_store:make_link(Store, Path, KeyHashPath),\r\n            % ...\r\n            Path\r\n        end,\r\n        hb_private:reset(Msg)\r\n    ),\r\n    % ...\r\n```\r\n\r\nThis approach:\r\n1. Calculates the unattested ID for the message\r\n2. Creates a group in the store for the message content\r\n3. Recursively writes each key-value pair\r\n4. Creates links for each key to the underlying data\r\n5. Special-cases device maps to prevent infinite recursion\r\n\r\n### Message Reading\r\n\r\nReading a message involves retrieving the raw data and then applying type information:\r\n\r\n```erlang\r\nread(Path, Opts) ->\r\n    case store_read(Path, hb_opts:get(store, no_viable_store, Opts), Opts) of\r\n        not_found -> not_found;\r\n        {ok, Res} ->\r\n            ?event({applying_types_to_read_message, Res}),\r\n            Structured = dev_codec_structured:to(Res),\r\n            ?event({finished_read, Structured}),\r\n            {ok, Structured}\r\n    end.\r\n```\r\n\r\nThe internal `store_read` function handles path resolution, circular reference detection, and recursively rebuilding complex messages:\r\n\r\n```erlang\r\ndo_read(Path, Store, Opts, AlreadyRead) ->\r\n    ResolvedFullPath = hb_store:resolve(Store, PathToBin = hb_path:to_binary(Path)),\r\n    ?event({reading, {path, PathToBin}, {resolved, ResolvedFullPath}}),\r\n    case hb_store:type(Store, ResolvedFullPath) of\r\n        not_found -> not_found;\r\n        no_viable_store -> not_found;\r\n        simple -> hb_store:read(Store, ResolvedFullPath);\r\n        _ ->\r\n            case hb_store:list(Store, ResolvedFullPath) of\r\n                {ok, Subpaths} ->\r\n                    % ... (builds a map from subpaths) ...\r\n                    Msg = maps:from_list(\r\n                        lists:map(\r\n                            fun(Subpath) ->\r\n                                {ok, Res} = store_read(\r\n                                    [ResolvedFullPath, Subpath],\r\n                                    Store,\r\n                                    Opts,\r\n                                    [ResolvedFullPath | AlreadyRead]\r\n                                ),\r\n                                {iolist_to_binary([Subpath]), Res}\r\n                            end,\r\n                            Subpaths\r\n                        )\r\n                    ),\r\n                    % ...\r\n                    {ok, Msg};\r\n                _ -> not_found\r\n            end\r\n    end.\r\n```\r\n\r\n### Compute Result Caching\r\n\r\nThe `read_resolved` function provides a specialized lookup for computation results:\r\n\r\n```erlang\r\nread_resolved(MsgID1, MsgID2, Opts) when ?IS_ID(MsgID1) and ?IS_ID(MsgID2) ->\r\n    ?event({cache_lookup, {msg1, MsgID1}, {msg2, MsgID2}, {opts, Opts}}),\r\n    read(<<MsgID1/binary, \"/\", MsgID2/binary>>, Opts);\r\nread_resolved(MsgID1, Msg2, Opts) when ?IS_ID(MsgID1) and is_map(Msg2) ->\r\n    {ok, MsgID2} = dev_message:id(Msg2, #{ <<\"attestors\">> => <<\"all\">> }, Opts),\r\n    read(<<MsgID1/binary, \"/\", MsgID2/binary>>, Opts);\r\nread_resolved(Msg1, Msg2, Opts) when is_map(Msg1) and is_map(Msg2) ->\r\n    read(hb_path:hashpath(Msg1, Msg2, Opts), Opts);\r\nread_resolved(_, _, _) -> not_found.\r\n```\r\n\r\nThis allows efficient lookup of previous computation results between two messages, supporting both ID-based and direct message lookups.\r\n\r\n\n\n## Tests\r\n\r\nThe module includes extensive tests that verify:\r\n\r\n1. **Binary Storage**: Testing simple binary storage and retrieval\r\n2. **Empty Message Storage**: Validating handling of empty messages\r\n3. **Unsigned Message Storage**: Testing storage of unsigned messages\r\n4. **Signed Message Storage**: Verifying attestation handling\r\n5. **Deeply Nested Messages**: Testing recursive handling of complex nested structures\r\n6. **ANS104 Message Format**: Testing compatibility with the ANS104 specification\r\n7. **Safety Guards**: Ensuring circular references are prevented\r\n\r\nThese tests provide comprehensive validation of the module's functionality and robustness.\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Storage Subsystem\r\n\r\n`hb_cache.erl` builds directly on top of the storage abstraction provided by `hb_store`, using its functionality for the actual data persistence while adding domain-specific logic for message handling.\r\n\r\n### Integration with Messaging Subsystem\r\n\r\nThe module is tightly integrated with the messaging subsystem, with special handling for attestations and message formats, ensuring that the persistence layer correctly preserves the semantic structure of messages.\r\n\r\n### Integration with Path System\r\n\r\nThe use of `hb_path` for hashpath generation and path manipulation shows the interconnection with the path management subsystem, leveraging its functionality for creating content-addressed locations.\r\n\r\n### Integration with Compute Subsystem\r\n\r\nThe `read_resolved` function specifically targets caching computation results, suggesting integration with the computation subsystem to avoid redundant work.",
  "description": "`hb_cache.erl` is a sophisticated caching and persistence layer for Converge Protocol messages and compute results in HyperBEAM. The module provides an intelligent storage system that automatically handles content deduplication, attestation linking, and hierarchical data structures, all while leveraging the underlying storage backends provided by the `hb_store` abstraction.",
  "hasCode": true
}
