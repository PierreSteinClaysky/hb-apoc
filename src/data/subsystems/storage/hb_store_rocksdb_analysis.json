{
  "name": "`hb_store_rocksdb",
  "subsystem": "storage",
  "filename": "hb_store_rocksdb.erl",
  "content": "# `hb_store_rocksdb.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_store_rocksdb.erl` provides a high-performance persistent storage implementation using RocksDB, a key-value store optimized for fast storage. Unlike the filesystem implementation, which leverages the operating system's directory structure, this module emulates hierarchical paths and directories within the flat key-value store structure of RocksDB.\r\n\r\nThis implementation combines the structured path handling of the filesystem store with the performance characteristics of RocksDB, wrapped in a stateful Erlang process that manages the database connection. As stated in the module documentation, it \"replicates functionality of the hb_fs_store module\" while leveraging a different storage backend.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Process-Based Implementation**: Implements both `gen_server` and `hb_store` behaviors\r\n- **RocksDB Backend**: Uses RocksDB for high-performance key-value storage\r\n- **Type-Tagged Values**: Encodes value types (link, raw, group) within the stored data\r\n- **Emulated Directory Structure**: Simulates hierarchical paths in the flat key-value store\r\n- **Local Scope**: Marked as having a \"local\" scope in the storage ecosystem\r\n- **Comprehensive Testing**: Includes extensive test coverage for all operations\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `gen_server`: Uses OTP's gen_server behavior for process management\r\n- `hb_store`: Implements the behavior defined by this module\r\n- `rocksdb`: Erlang bindings for the RocksDB database\r\n- `filelib`: Used for directory operations\r\n- `include/hb.hrl`: System-wide macros and definitions\r\n\r\n\n\n## Implementation Details\r\n\r\n### Process Management\r\n\r\nThe module implements the `gen_server` behavior, managing a stateful process that holds the RocksDB database handle:\r\n\r\n```erlang\r\nstart_link(#{ <<\"store-module\">> := hb_store_rocksdb, <<\"prefix\">> := Dir}) ->\r\n    gen_server:start_link({local, ?MODULE}, ?MODULE, Dir, []);\r\n```\r\n\r\nThis design allows the module to maintain a persistent connection to the database while providing the `hb_store` behavior interface to the rest of the system.\r\n\r\n### Value Encoding\r\n\r\nValues stored in RocksDB are tagged with a type indicator to differentiate between different types of stored values:\r\n\r\n```erlang\r\n-spec encode_value(value_type(), binary()) -> binary().\r\nencode_value(link, Value)  -> <<1, Value/binary>>;\r\nencode_value(raw, Value)   -> <<2, Value/binary>>;\r\nencode_value(group, Value) -> <<3, (term_to_binary(Value))/binary>>.\r\n\r\n-spec decode_value(binary()) -> {value_type(), binary()}.\r\ndecode_value(<<1, Value/binary>>) -> {link, Value};\r\ndecode_value(<<2, Value/binary>>) -> {raw, Value};\r\ndecode_value(<<3, Value/binary>>) -> {group, binary_to_term(Value)}.\r\n```\r\n\r\nThis encoding scheme allows the module to store different types of data in the same key-value store while maintaining type information.\r\n\r\n### Directory Structure Emulation\r\n\r\nThe module emulates a directory structure within the flat key-value space of RocksDB:\r\n\r\n```erlang\r\nensure_dir(DBHandle, BaseDir) ->\r\n    PathParts = hb_path:term_to_path_parts(BaseDir),\r\n    [First | Rest] = PathParts,\r\n    Result = ensure_dir(DBHandle, First, Rest),\r\n    Result.\r\n    \r\n% ... (implementation continues)\r\n```\r\n\r\nGroups (directories) are represented as special entries in the database, with their content stored as Erlang sets serialized to binary. This allows for efficient lookup and modification of directory contents.\r\n\r\n### Core Storage Operations\r\n\r\n#### Reading\r\n\r\n```erlang\r\nread(Opts, RawPath) ->\r\n    ?event({read, RawPath}),\r\n    Path = resolve(Opts, RawPath),\r\n    case do_read(Opts, Path) of\r\n        not_found ->\r\n            not_found;\r\n        {error, _Reason} = Err -> Err;\r\n        {ok, {raw, Result}} ->\r\n            {ok, Result};\r\n        {ok, {link, Link}} ->\r\n            ?event({link_found, Path, Link}),\r\n            read(Opts, Link);\r\n        {ok, {group, _Result}} ->\r\n            not_found\r\n    end.\r\n```\r\n\r\nReading follows a similar pattern to the filesystem implementation, resolving paths and following links, but with the underlying storage operations delegated to RocksDB.\r\n\r\n#### Writing\r\n\r\n```erlang\r\nwrite(Opts, RawKey, Value) ->\r\n    Key = hb_store:join(RawKey),\r\n    EncodedValue = encode_value(raw, Value),\r\n    ?event({writing, Key, byte_size(EncodedValue)}),\r\n    do_write(Opts, Key, EncodedValue).\r\n```\r\n\r\nWriting encodes the value as a \"raw\" type and delegates to the `do_write` function, which handles the actual RocksDB operation and directory structure maintenance.\r\n\r\n#### Path Resolution\r\n\r\n```erlang\r\nresolve(Opts, Path) ->\r\n    PathList = hb_path:term_to_path_parts(hb_store:join(Path)),\r\n    ResolvedPath = do_resolve(Opts, \"\", PathList),\r\n    ResolvedPath.\r\n\r\ndo_resolve(_Opts, FinalPath, []) ->\r\n    FinalPath;\r\ndo_resolve(Opts, CurrentPath, [CurrentPath | Rest]) ->\r\n    do_resolve(Opts, CurrentPath, Rest);\r\ndo_resolve(Opts, CurrentPath, [Next | Rest]) ->\r\n    PathPart = hb_store:join([CurrentPath, Next]),\r\n    case do_read(Opts, PathPart) of\r\n        not_found -> do_resolve(Opts, PathPart, Rest);\r\n        {error, _Reason} = Err -> Err;\r\n        {ok, {link, LinkValue}} ->\r\n            do_resolve(Opts, LinkValue, Rest);\r\n        {ok, _OtherType} -> do_resolve(Opts, PathPart, Rest)\r\n    end.\r\n```\r\n\r\nThe path resolution logic is similar to that of the filesystem implementation, with segment-by-segment traversal and link resolution, but adapted to work with the RocksDB storage backend.\r\n\r\n### Directory Maintenance\r\n\r\n```erlang\r\nmaybe_append_key_to_group(Key, CurrentDirContents) ->\r\n    case decode_value(CurrentDirContents) of\r\n        {group, GroupSet} ->\r\n            BaseName = filename:basename(Key),\r\n            NewGroupSet = sets:add_element(BaseName, GroupSet),\r\n            encode_value(group, NewGroupSet);\r\n        _ ->\r\n            CurrentDirContents\r\n    end.\r\n```\r\n\r\nWhen writing a file, the module updates its parent directory's content list, maintaining the hierarchical structure within the flat key-value store.\r\n\r\n\n\n## Tests\r\n\r\nThe module includes extensive tests that verify all aspects of its functionality:\r\n\r\n1. **Basic Read/Write**: Testing the fundamental key-value storage operations\r\n2. **Link Following**: Verifying that symbolic links are properly followed\r\n3. **Directory Structure**: Ensuring the emulated directory structure works as expected\r\n4. **Type Detection**: Testing the type identification system\r\n5. **Path Resolution**: Verifying that paths are properly resolved, including link traversal\r\n6. **Reset Operation**: Testing that the database can be properly cleared\r\n\r\nThese tests provide a comprehensive verification of the implementation's correctness.\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Storage Abstraction\r\n\r\nAs with other storage implementations, this module implements the `hb_store` behavior, allowing it to be used seamlessly through the storage abstraction layer.\r\n\r\n### Integration with Path System\r\n\r\nThe module leverages the path manipulation utilities from `hb_path` and `hb_store` to handle path components and resolution consistently with other storage implementations.\r\n\r\n### Integration with Process Management\r\n\r\nUnlike some of the other storage implementations, this module integrates with OTP's process management system through the `gen_server` behavior, providing robust process lifecycle management.",
  "description": "`hb_store_rocksdb.erl` provides a high-performance persistent storage implementation using RocksDB, a key-value store optimized for fast storage. Unlike the filesystem implementation, which leverages the operating system's directory structure, this module emulates hierarchical paths and directories within the flat key-value store structure of RocksDB.",
  "hasCode": true
}