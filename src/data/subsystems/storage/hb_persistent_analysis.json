{
  "name": "`hb_persistent",
  "subsystem": "storage",
  "filename": "hb_persistent.erl",
  "content": "# `hb_persistent.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_persistent.erl` is an advanced process management module for HyperBEAM that creates and manages long-lived Converge resolution processes. It provides a mechanism for maintaining stateful processes that can handle expensive computations more efficiently by keeping large messages in memory and avoiding repeated serialization/deserialization operations. Additionally, it offers facilities for coordinating and serializing parallel executions to prevent redundant work.\r\n\r\nThis module bridges the gap between the storage subsystem and process management, functioning as a form of in-memory persistence that complements the disk-based storage implementations. It represents a higher-level approach to resource optimization by focusing on compute resources rather than storage resources.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Long-Lived Process Management**: Creates and manages persistent processes for Converge resolution\r\n- **Execution Deduplication**: Prevents redundant parallel execution of identical computations\r\n- **Process Coordination**: Allows processes to register as leaders for specific executions\r\n- **Distributed Group Management**: Built on Erlang's process group mechanism for distributed coordination\r\n- **Configurable Execution Strategy**: Supports customizable worker, grouping, and await functions\r\n- **Process Monitoring**: Includes utilities for monitoring process groups and their states\r\n- **Result Notification**: Handles notification of waiting processes when results are available\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_name`: For process registration and lookup (wraps Erlang's `pg` module)\r\n- `hb_converge`: For execution of Converge resolution\r\n- `hb_opts`: For accessing configuration options\r\n- `erlang`: For process monitoring and management primitives\r\n- `include/hb.hrl`: System-wide macros and definitions\r\n\r\n\n\n## Implementation Details\r\n\r\n### Process Coordination\r\n\r\nThe module implements a leader-follower pattern for coordinating parallel executions:\r\n\r\n```erlang\r\nfind_or_register(GroupName, _Msg1, _Msg2, Opts) ->\r\n    case hb_opts:get(await_inprogress, false, Opts) of\r\n        false -> {leader, GroupName};\r\n        _ ->\r\n            Self = self(),\r\n            case find_execution(GroupName, Opts) of\r\n                {ok, Leader} when Leader =/= Self ->\r\n                    ?event({found_leader, GroupName, {leader, Leader}}),\r\n                    {wait, Leader};\r\n                {ok, Leader} when Leader =:= Self ->\r\n                    {infinite_recursion, GroupName};\r\n                _ ->\r\n                    ?event(\r\n                        {\r\n                            register_resolver,\r\n                            {group, GroupName}\r\n                        }\r\n                    ),\r\n                    register_groupname(GroupName, Opts),\r\n                    {leader, GroupName}\r\n            end\r\n    end.\r\n```\r\n\r\nThis function checks if a process is already handling a specific execution (identified by a group name). If so, it returns a directive to wait for that process; otherwise, it registers the current process as the leader for that execution.\r\n\r\n### Process Grouping\r\n\r\nThe module includes a flexible strategy for grouping related executions:\r\n\r\n```erlang\r\ngroup(Msg1, Msg2, Opts) ->\r\n    Grouper =\r\n        maps:get(grouper, hb_converge:info(Msg1, Opts), fun default_grouper/3),\r\n    apply(\r\n        Grouper,\r\n        hb_converge:truncate_args(Grouper, [Msg1, Msg2, Opts])\r\n    ).\r\n```\r\n\r\nThis allows customization of how executions are grouped, with a default implementation that uses a hash of the message pair:\r\n\r\n```erlang\r\ndefault_grouper(Msg1, Msg2, Opts) ->\r\n    % Use Erlang's `phash2` to hash the result of the Grouper function.\r\n    ?no_prod(\"Using a hash for group names is not secure.\"),\r\n    case hb_opts:get(await_inprogress, true, Opts) of\r\n        named -> ungrouped_exec;\r\n        _ -> erlang:phash2({Msg1, Msg2})\r\n    end.\r\n```\r\n\r\n### Worker Process Management\r\n\r\nThe module provides functions for starting and managing worker processes:\r\n\r\n```erlang\r\nstart_worker(GroupName, Msg, Opts) ->\r\n    start(),\r\n    ?event(worker_spawns,\r\n        {starting_worker, {group, GroupName}, {msg, Msg}, {opts, Opts}}\r\n    ),\r\n    WorkerPID = spawn(\r\n        fun() ->\r\n            % If the device's info contains a `worker` function we\r\n            % use that instead of the default implementation.\r\n            WorkerFun =\r\n                maps:get(\r\n                    worker,\r\n                    hb_converge:info(Msg, Opts),\r\n                    Def = fun default_worker/3\r\n                ),\r\n            % ... (initialization logic)\r\n            register_groupname(GroupName, Opts),\r\n            apply(\r\n                WorkerFun,\r\n                hb_converge:truncate_args(\r\n                    WorkerFun,\r\n                    [\r\n                        GroupName,\r\n                        Msg,\r\n                        maps:merge(Opts, #{\r\n                            is_worker => true,\r\n                            spawn_worker => false,\r\n                            allow_infinite => true\r\n                        })\r\n                    ]\r\n                )\r\n            )\r\n        end\r\n    ),\r\n    WorkerPID.\r\n```\r\n\r\nThe default worker implementation shows the main processing loop:\r\n\r\n```erlang\r\ndefault_worker(GroupName, Msg1, Opts) ->\r\n    Timeout = hb_opts:get(worker_timeout, 10000, Opts),\r\n    worker_event(GroupName, default_worker_waiting_for_req, Msg1, undefined, Opts),\r\n    receive\r\n        {resolve, Listener, GroupName, Msg2, ListenerOpts} ->\r\n            % ... (process the request)\r\n            Res =\r\n                hb_converge:resolve(\r\n                    Msg1,\r\n                    Msg2,\r\n                    maps:merge(ListenerOpts, Opts)\r\n                ),\r\n            send_response(Listener, GroupName, Msg2, Res),\r\n            notify(GroupName, Msg2, Res, Opts),\r\n            % ... (determine next action based on configuration)\r\n    after Timeout ->\r\n        % We have hit the in-memory persistence timeout. Check whether the\r\n        % device has shutdown procedures (for example, writing in-memory\r\n        % state to the cache).\r\n        unregister(Msg1, undefined, Opts)\r\n    end.\r\n```\r\n\r\n### Result Notification and Waiting\r\n\r\nThe module includes functions for notifying waiting processes about results and for waiting for results from other processes:\r\n\r\n```erlang\r\nnotify(GroupName, Msg2, Msg3, Opts) ->\r\n    % ... (debug logging)\r\n    receive\r\n        {resolve, Listener, GroupName, Msg2, _ListenerOpts} ->\r\n            ?event({notifying_listener, {listener, Listener}, {group, GroupName}}),\r\n            send_response(Listener, GroupName, Msg2, Msg3),\r\n            notify(GroupName, Msg2, Msg3, Opts)\r\n    after 0 ->\r\n        ?event(finished_notify),\r\n        ok\r\n    end.\r\n```\r\n\r\n```erlang\r\nawait(Worker, Msg1, Msg2, Opts) ->\r\n    % ... (get the device's await function)\r\n    GroupName = group(Msg1, Msg2, Opts),\r\n    % set monitor to a worker, so we know if it exits\r\n    _Ref = erlang:monitor(process, Worker),\r\n    Worker ! {resolve, self(), GroupName, Msg2, Opts},\r\n    AwaitFun(Worker, GroupName, Msg1, Msg2, Opts).\r\n```\r\n\r\nThe default await implementation shows how a process waits for a result and handles worker failures:\r\n\r\n```erlang\r\ndefault_await(Worker, GroupName, Msg1, Msg2, Opts) ->\r\n    % Wait for the result.\r\n    receive\r\n        {resolved, _, GroupName, Msg2, Res} ->\r\n            worker_event(GroupName, {resolved_await, Res}, Msg1, Msg2, Opts),\r\n            Res;\r\n        {'DOWN', _R, process, Worker, Reason} ->\r\n            ?event(\r\n                {leader_died,\r\n                    {group, GroupName},\r\n                    {leader, Worker},\r\n                    {reason, Reason},\r\n                    {request, Msg2}\r\n                }\r\n            ),\r\n            {error, leader_died}\r\n    end.\r\n```\r\n\r\n\n\n## Tests\r\n\r\nThe module includes comprehensive tests demonstrating its capabilities:\r\n\r\n1. **Deduplicated Execution**: Shows how parallel requests for the same computation are deduplicated\r\n2. **Persistent Worker**: Tests the creation and operation of a persistent worker\r\n3. **Spawning After Execution**: Tests spawning new workers after execution completes\r\n\r\nThese tests verify that the module correctly handles parallel execution, maintains state, and manages the lifecycle of worker processes.\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Converge Protocol\r\n\r\nThe module works closely with the Converge Protocol (`hb_converge`) for message resolution, showing how it fits into the core execution model.\r\n\r\n### Integration with Process Management\r\n\r\nThe module leverages Erlang's process management primitives and the `pg` module (through `hb_name`) for distributed process coordination.\r\n\r\n### Integration with Configuration System\r\n\r\nThe module uses `hb_opts` extensively to access configuration options, allowing its behavior to be customized based on system configuration.",
  "description": "`hb_persistent.erl` is an advanced process management module for HyperBEAM that creates and manages long-lived Converge resolution processes. It provides a mechanism for maintaining stateful processes that can handle expensive computations more efficiently by keeping large messages in memory and avoiding repeated serialization/deserialization operations. Additionally, it offers facilities for coordinating and serializing parallel executions to prevent redundant work.",
  "hasCode": true
}