{
  "name": "`hb_store",
  "subsystem": "storage",
  "filename": "hb_store.erl",
  "content": "# `hb_store.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_store.erl` serves as an abstraction layer for key-value store operations in HyperBEAM, providing a unified interface across multiple storage backend implementations. As noted in the code comments, \"This interface allows us to swap out the underlying store implementation(s) as desired.\"\r\n\r\nWith 14 downstream dependents according to our Stage 1 analysis, this module plays a critical role in the system's data persistence strategy. The module allows operations to be attempted across a list of storage modules, falling back if earlier modules fail.\r\n\r\n\n\n## Key Characteristics\r\n\r\n- **Storage Backend Abstraction**: Provides a uniform interface to different storage implementations\r\n- **Behavior Definition**: Defines a callback behavior that storage modules must implement\r\n- **Cascading Implementation**: Falls back to alternative implementations if a module fails\r\n- **Hierarchical Paths**: Supports directory-like structures with groups and path components\r\n- **Symbolic Link Support**: Provides link functionality between different paths\r\n- **Scope-Based Filtering**: Allows filtering and sorting store modules by scope (e.g., local, remote)\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n`hb_store.erl` has minimal dependencies, which is appropriate for a foundational module:\r\n- `include/hb.hrl`: System-wide macros and definitions\r\n- `eunit/include/eunit.hrl`: Testing framework includes\r\n- `hb_path`: Used for path manipulation (specifically the `to_binary/1` function)\r\n\r\n### Downstream Dependents\r\n\r\nAccording to our Stage 1 analysis, 14 other modules depend on this module, spanning several subsystems:\r\n\r\n1. **Storage Implementations**:\r\n   - `hb_store_fs.erl`\r\n   - `hb_store_gateway.erl`\r\n   - `hb_store_remote_node.erl`\r\n   - `hb_store_rocksdb.erl`\r\n\r\n2. **Cache System**:\r\n   - `hb_cache.erl`\r\n   - `hb_cache_control.erl`\r\n   - `hb_cache_render.erl`\r\n\r\n3. **Core Components**:\r\n   - `hb_converge_test_vectors.erl`\r\n   - `hb_http_server.erl`\r\n\r\n4. **Device Components**:\r\n   - `dev_process.erl`\r\n   - `dev_process_cache.erl`\r\n   - `dev_scheduler_cache.erl`\r\n\r\n\n\n## Key Functions\r\n\r\n### Behavior Definition\r\n\r\n```erlang\r\nbehavior_info(callbacks) ->\r\n    [\r\n        {start, 1}, {stop, 1}, {reset, 1}, {make_group, 2}, {make_link, 3},\r\n        {type, 2}, {read, 2}, {write, 3},\r\n        {list, 2}, {path, 2}, {add_path, 3}\r\n    ].\r\n```\r\n\r\nThis defines the required callbacks that any storage implementation module must provide.\r\n\r\n### Store Management\r\n\r\n- `start/1`: Starts all storage modules in the list\r\n- `stop/1`: Stops all storage modules in the list\r\n- `reset/1`: Resets (clears) all storage modules\r\n\r\n### Core Storage Operations\r\n\r\n- `read/2`: Reads a value from a key\r\n- `write/3`: Writes a value to a key\r\n- `type/2`: Gets the type of element at a given path\r\n- `list/2`: Lists keys in a group (with a warning about potential performance impact)\r\n\r\n### Store Selection and Management\r\n\r\n- `filter/2`: Filters store modules based on a predicate\r\n- `scope/2`: Limits store modules to those with a specific scope\r\n- `sort/2`: Orders store modules by a preference order of scopes\r\n\r\n### Path and Structure Operations\r\n\r\n- `path/1, path/2`: Creates a path from components\r\n- `add_path/2, add_path/3`: Combines path components\r\n- `join/1`: Joins a list of path components\r\n- `make_group/2`: Creates a \"group\" (directory-like namespace)\r\n- `make_link/3`: Creates a link from one path to another\r\n- `resolve/2`: Follows links to resolve a path to its final target\r\n\r\n### Implementation Helpers\r\n\r\n- `call_function/3`: Tries to call a function on each store module until one succeeds\r\n- `call_all/3`: Calls a function on all store modules\r\n\r\n### Testing Support\r\n\r\n- `test_stores/0`: Returns a list of test store configurations\r\n- `generate_test_suite/1, generate_test_suite/2`: Generates test suites for store modules\r\n\r\n\n\n## Implementation Details\r\n\r\n### Store Module Format\r\n\r\nStore modules are represented as maps with a required `<<\"store-module\">>` key that points to the Erlang module implementing the store behavior:\r\n\r\n```erlang\r\nStore = #{<<\"store-module\">> := Mod}\r\n```\r\n\r\n### Cascading Implementation Pattern\r\n\r\nThe module uses a cascading pattern where it attempts operations on each store in sequence until one succeeds:\r\n\r\n```erlang\r\ncall_function([Store = #{<<\"store-module\">> := Mod} | Rest], Function, Args) ->\r\n    try apply(Mod, Function, [Store | Args]) of\r\n        not_found ->\r\n            call_function(Rest, Function, Args);\r\n        Result ->\r\n            Result\r\n    catch\r\n        Class:Reason:Stacktrace ->\r\n            ?event(error, {store_call_failed, {Class, Reason, Stacktrace}}),\r\n            call_function(Rest, Function, Args)\r\n    end.\r\n```\r\n\r\nThis pattern provides robustness through fallbacks.\r\n\r\n### Store Scoping\r\n\r\nStores have a concept of \"scope\" (e.g., local, remote) that can be used for filtering:\r\n\r\n```erlang\r\nfilter(Modules, Filter) ->\r\n    lists:filter(\r\n        fun(Store) ->\r\n            try Filter(get_store_scope(Store), Store)\r\n            catch _:_ -> false\r\n            end\r\n        end,\r\n        Modules\r\n    ).\r\n```\r\n\r\n\n\n## Integration with Other Subsystems\r\n\r\n### Integration with Cache System\r\n\r\nThe cache system (`hb_cache.erl` and related modules) appears to build on top of the storage abstraction, likely providing an in-memory caching layer that falls back to persistent storage.\r\n\r\n### Integration with Path System\r\n\r\nThe module closely integrates with the path manipulation system:\r\n\r\n```erlang\r\njoin(Path) -> hb_path:to_binary(Path).\r\n```\r\n\r\n### Integration with Device System\r\n\r\nDevice components (e.g., `dev_process.erl`, `dev_scheduler_cache.erl`) depend on the storage subsystem, suggesting that device state and computation results are persisted through this abstraction.\r\n\r\n### Integration with HTTP System\r\n\r\nThe dependency from `hb_http_server.erl` suggests that the HTTP system may use the storage abstraction for persisting API data or serving content.",
  "description": "`hb_store.erl` serves as an abstraction layer for key-value store operations in HyperBEAM, providing a unified interface across multiple storage backend implementations. As noted in the code comments, \"This interface allows us to swap out the underlying store implementation(s) as desired.\"",
  "hasCode": true
}