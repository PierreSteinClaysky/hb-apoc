{
  "name": "`hb_util",
  "subsystem": "core",
  "filename": "hb_util.erl",
  "content": "# `hb_util.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_util.erl` is a foundational utility module in HyperBEAM that provides a collection of general-purpose helper functions and utilities used extensively throughout the codebase. With 49 dependents as identified in our Stage 1, this is one of the most critical files in the codebase.\r\n\r\nThe module serves multiple purposes:\r\n- Type conversion and data normalization\r\n- ID handling and formatting\r\n- Message utility functions\r\n- Data transformation utilities\r\n- Debugging and tracing utilities\r\n- Error handling\r\n- String and binary manipulation\r\n- Statistical functions\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\nThe module has minimal upstream dependencies, which is expected for a foundational utility module:\r\n- Includes `include/hb.hrl` for system-wide macros and definitions\r\n\r\n### Downstream Dependents\r\n\r\n49 other modules depend on this file according to Stage 1 analysis, making it one of the two most widely-used files in the system (along with `hb_converge.erl`).\r\n\r\n\n\n## Key Functions\r\n\r\n### Type Conversion\r\n\r\n- `int/1`: Coerces strings, binaries, and integers to integer type\r\n- `float/1`: Coerces strings, binaries, and floats to float type\r\n- `atom/1`: Coerces strings and binaries to atoms (using existing atoms only for safety)\r\n- `bin/1`: Coerces various types (atoms, integers, floats, lists) to binary format\r\n- `list/1`: Coerces values to list format\r\n\r\n### ID Handling\r\n\r\n- `id/1`, `id/2`: Converts between different ID formats (human-readable, native binary)\r\n- `native_id/1`: Converts a human-readable ID to a native binary ID\r\n- `human_id/1`: Converts a native binary ID to a human-readable ID\r\n- `short_id/1`: Creates a shortened version of an ID for display purposes\r\n- `encode/1`, `decode/1`: Base64 encoding/decoding of binaries\r\n- `safe_encode/1`, `safe_decode/1`: Safer versions that handle errors\r\n\r\n### Message Utilities\r\n\r\n- `find_value/2`, `find_value/3`: Locates a specific key in a Converge message with optional default\r\n- `number/1`: Labels a list of elements with numbers\r\n- `list_to_numbered_map/1`: Converts a list to a map with numbered keys\r\n- `message_to_ordered_list/1`: Converts a message with numbered keys to an ordered list\r\n\r\n### Data Structure Manipulation\r\n\r\n- `hd/1`, `hd/2`, `hd/3`: Enhanced version of the built-in `hd` function for Converge messages\r\n- `is_string_list/1`: Tests if a list is a valid string\r\n- `to_sorted_list/1`: Converts maps or key-value lists to a deterministically sorted list\r\n- `to_sorted_keys/1`: Returns deterministically sorted keys from a map or list\r\n- `key_to_atom/2`: Converts keys to atoms, replacing dashes with underscores\r\n\r\n### Error Handling\r\n\r\n- `ok/1`, `ok/2`: Unwraps an `{ok, Value}` tuple or throws/returns based on error strategy\r\n- `maybe_throw/2`: Conditionally throws an exception based on options\r\n\r\n### Tracing and Debugging\r\n\r\n- `debug_print/4`: Sophisticated debugging output with timing information\r\n- `debug_fmt/1`, `debug_fmt/2`: Formats terms for debug output with customizable indentation\r\n- `print_trace/4`: Prints stack traces to the standard error stream\r\n- `trace_macro_helper/5`: Helps macros remove the first frame of the stack trace\r\n- `format_trace_short/1`: Formats a trace as a compact string\r\n\r\n### Statistical Functions\r\n\r\n- `count/2`: Counts occurrences of an item in a list\r\n- `mean/1`: Calculates the arithmetic mean of a list of numbers\r\n- `stddev/1`: Calculates the standard deviation of a list of numbers\r\n- `variance/1`: Calculates the variance of a list of numbers\r\n\r\n\n\n## Usage Patterns\r\n\r\nThe `hb_util` module shows several distinctive usage patterns:\r\n\r\n1. **Defensive Programming**:\r\n   - Type coercion functions handle multiple input types gracefully\r\n   - Error handling functions allow configurable behavior (throwing vs. returning)\r\n   - Safe encoding/decoding functions that won't crash on invalid input\r\n\r\n2. **Pretty Printing and Debug Support**:\r\n   - Sophisticated debug formatting with customizable indentation\r\n   - Trace functions with filtering to focus on relevant modules\r\n   - Short ID generation for human-readable display\r\n\r\n3. **Deterministic Processing**:\r\n   - Functions like `to_sorted_list/1` ensure deterministic ordering\r\n   - Normalization functions handle edge cases\r\n\r\n4. **JSON/API Support**:\r\n   - Functions like `find_value/3` help with parsing structures like JSON\r\n   - Key normalization functions standardize formats\r\n\r\n\n\n## Integration Points\r\n\r\n`hb_util` integrates with other components through several key mechanisms:\r\n\r\n1. **ID Transformation Chain**:\r\n   - Functions `encode/1`, `decode/1`, `native_id/1`, and `human_id/1` form a chain for transforming between different ID formats used by the system\r\n   - These functions appear in network code, storage code, and user-facing components\r\n\r\n2. **Message Manipulation**:\r\n   - Functions that manipulate Converge messages are used by the message processing subsystem\r\n   - `hb_converge.erl` relies on utility functions like `normalize_key/1` for consistent key handling\r\n\r\n3. **Error Handling**:\r\n   - The `ok/1` and `ok/2` functions establish a pattern for error handling used throughout the codebase\r\n   - The `maybe_throw/2` function implements configurable error behavior\r\n\r\n4. **Debugging Infrastructure**:\r\n   - Debug functions create a coherent debugging system used across different modules\r\n   - Trace functions offer a consistent interface for trace capture and formatting\r\n\r\n\n\n## Code Snippets\r\n\r\n### ID Conversion Pattern\r\n\r\n```erlang\r\n%% @doc Return the human-readable form of an ID of a message when given either\r\n%% a message explicitly, raw encoded ID, or an Erlang Arweave `tx' record.\r\nid(Item) -> id(Item, unsigned).\r\nid(TX, Type) when is_record(TX, tx) ->\r\n    encode(ar_bundles:id(TX, Type));\r\nid(Map, Type) when is_map(Map) ->\r\n    hb_message:id(Map, Type);\r\nid(Bin, _) when is_binary(Bin) andalso byte_size(Bin) == 43 ->\r\n    Bin;\r\nid(Bin, _) when is_binary(Bin) andalso byte_size(Bin) == 32 ->\r\n    encode(Bin);\r\nid(Data, Type) when is_list(Data) ->\r\n    id(list_to_binary(Data), Type).\r\n```\r\n\r\n### Deterministic Sorting\r\n\r\n```erlang\r\n%% @doc Given a map or KVList, return a deterministically sorted list of its\r\n%% key-value pairs.\r\nto_sorted_list(Msg) when is_map(Msg) ->\r\n    to_sorted_list(maps:to_list(Msg));\r\nto_sorted_list(Msg) when is_list(Msg) ->\r\n    lists:sort(fun({Key1, _}, {Key2, _}) -> Key1 < Key2 end, Msg).\r\n```\r\n\r\n### Debug Formatting\r\n\r\n```erlang\r\n%% @doc Print a message to the standard error stream, prefixed by the amount\r\n%% of time that has elapsed since the last call to this function.\r\ndebug_print(X, Mod, Func, LineNum) ->\r\n    Now = erlang:system_time(millisecond),\r\n    Last = erlang:put(last_debug_print, Now),\r\n    TSDiff = case Last of undefined -> 0; _ -> Now - Last end,\r\n    io:format(standard_error, \"=== HB DEBUG ===[~pms in ~p @ ~s]==>~n~s~n\",\r\n        [\r\n            TSDiff, self(),\r\n            format_debug_trace(Mod, Func, LineNum),\r\n            debug_fmt(X, 0)\r\n        ]),\r\n    X.\r\n```",
  "description": "`hb_util.erl` is a foundational utility module in HyperBEAM that provides a collection of general-purpose helper functions and utilities used extensively throughout the codebase. With 49 dependents as identified in our Stage 1, this is one of the most critical files in the codebase.",
  "hasCode": true
}