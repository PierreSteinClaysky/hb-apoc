{
  "name": "`hb_path",
  "subsystem": "core",
  "filename": "hb_path.erl",
  "content": "# `hb_path.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_path.erl` is a foundational module in HyperBEAM that provides utilities for manipulating two distinct types of paths in messages:\r\n\r\n1. **Request Path** (simply called `Path`): The path that directs how a message should be processed\r\n2. **HashPath**: A cryptographic chain representing the history of message transformations\r\n\r\nThe HashPath is a critical component of the Converge Protocol's security model. It functions as a rolling Merkle list of messages that have been applied to generate a given message, creating a cryptographically verifiable audit trail. This mechanism ensures that message histories cannot be forged and allows verification of the complete computational history of any message.\r\n\r\nThe module handles path parsing, manipulation, matching, and the critical cryptographic functionality around HashPath generation and verification.\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\nThe module has dependencies on:\r\n- `include/hb.hrl` for system-wide macros and definitions\r\n- `include_lib(\"eunit/include/eunit.hrl\")` for test scaffolding\r\n- `hb_converge` for key normalization\r\n- `hb_util` for ID handling and utility functions\r\n- `hb_private` for private field access\r\n- `hb_crypto` for cryptographic operations (SHA-256, etc.)\r\n\r\n### Downstream Dependents\r\n\r\nThis module is used by core system components that need to:\r\n- Process paths in messages\r\n- Generate and verify cryptographic proof of message history\r\n- Manage message execution paths\r\n\r\n\n\n## Key Functions\r\n\r\n### HashPath Management\r\n\r\n- `hashpath/2`, `hashpath/3`, `hashpath/4`: Generate a HashPath by combining a message's existing HashPath with a new message ID\r\n- `hashpath_alg/1`: Get the HashPath algorithm function for a message\r\n- `verify_hashpath/2`: Verify a message's HashPath against a list of messages representing its history\r\n\r\n### Request Path Manipulation\r\n\r\n- `hd/2`: Extract the first key from a message's Path field\r\n- `tl/2`: Return the message without its first path element\r\n- `push_request/2`: Add a message to the head of a request path\r\n- `queue_request/2`: Add a message to the end of a request path\r\n- `pop_request/2`: Remove and return the next element from a request path\r\n\r\n### Private Path Storage\r\n\r\n- `priv_remaining/2`: Return the remaining path of a message from its private storage\r\n- `priv_store_remaining/2`: Store the remaining path in a message's private storage\r\n\r\n### Path Parsing and Normalization\r\n\r\n- `term_to_path_parts/1`, `term_to_path_parts/2`: Convert a term into an executable path\r\n- `from_message/2`: Extract the request path or HashPath from a message\r\n- `to_binary/1`: Convert a path to a binary representation\r\n- `normalize/1`: Normalize a path to a binary with a leading slash\r\n\r\n### Path Matching\r\n\r\n- `matches/2`: Check if two keys match (case-insensitive)\r\n- `regex_matches/2`: Check if two keys match using regex patterns\r\n\r\n\n\n## Usage Patterns\r\n\r\nThe `hb_path` module exhibits several distinctive usage patterns:\r\n\r\n1. **Cryptographic Chaining for Verification**:\r\n   - Messages build on each other by incorporating previous HashPaths\r\n   - This creates a verifiable chain of transformations\r\n   - Custom HashPath algorithms can be specified for different security properties\r\n\r\n2. **Path-Based Message Processing**:\r\n   - The request path controls message execution flow\r\n   - Functions like `hd`, `tl`, and `pop_request` parse this execution path\r\n   - Pushing and queuing allows for dynamic path modification\r\n\r\n3. **Multi-Format Path Parsing**:\r\n   - Paths can be represented as binaries, lists, atoms, or complex nested structures\r\n   - The module provides normalization to create consistent representations\r\n   - Path matching functions support both exact and regex-based matching\r\n\r\n4. **Private Path Storage**:\r\n   - Some path information is stored in private message fields\r\n   - This separation protects the integrity of the execution path\r\n\r\n\n\n## Integration Points\r\n\r\n`hb_path` integrates with other components through several key mechanisms:\r\n\r\n1. **Message Resolution Pipeline**:\r\n   - Works closely with `hb_converge` resolution stages\r\n   - Provides path parsing used in key resolution\r\n   - Note: Functions are designed to avoid circular dependencies with `hb_converge`\r\n\r\n2. **Cryptographic Verification System**:\r\n   - Interfaces with `hb_crypto` for hashing operations\r\n   - Creates verifiable links between messages that can be audited\r\n\r\n3. **Message ID System**:\r\n   - HashPaths are incorporated into message IDs\r\n   - This creates an intrinsic link between identity and history\r\n\r\n4. **Private Message Fields**:\r\n   - Works with `hb_private` to store path-related metadata\r\n   - Ensures path information can't be tampered with\r\n\r\n\n\n## Code Snippets\r\n\r\n### HashPath Generation\r\n\r\n```erlang\r\nhashpath(Msg1, Msg2, HashpathAlg, Opts) when is_map(Msg2) ->\r\n    Msg2WithoutMeta = maps:without(?CONVERGE_KEYS, Msg2),\r\n    ReqPath = from_message(request, Msg2),\r\n    case {map_size(Msg2WithoutMeta), ReqPath} of\r\n        {0, _} when ReqPath =/= undefined ->\r\n            hashpath(Msg1, to_binary(hd(ReqPath)), HashpathAlg, Opts);\r\n        _ ->\r\n            {ok, Msg2ID} =\r\n                dev_message:id(\r\n                    Msg2,\r\n                    #{ <<\"attestors\">> => <<\"all\">> },\r\n                    Opts\r\n                ),\r\n            hashpath(Msg1, hb_util:human_id(Msg2ID), HashpathAlg, Opts)\r\n    end;\r\n```\r\n\r\n### Path Element Extraction\r\n\r\n```erlang\r\npop_request(Msg, Opts) when is_map(Msg) ->\r\n    case pop_request(from_message(request, Msg), Opts) of\r\n        undefined -> undefined;\r\n        {undefined, _} -> undefined;\r\n        {Head, []} -> {Head, undefined};\r\n        {Head, Rest} ->\r\n            ?event({popped_request, Head, Rest}),\r\n            {Head, maps:put(<<\"path\">>, Rest, Msg)}\r\n    end;\r\n```\r\n\r\n### Term to Path Conversion\r\n\r\n```erlang\r\nterm_to_path_parts(Binary, Opts) when is_binary(Binary) ->\r\n    case binary:match(Binary, <<\"/\">>) of\r\n        nomatch -> [Binary];\r\n        _ ->\r\n            term_to_path_parts(\r\n                binary:split(Binary, <<\"/\">>, [global, trim_all]),\r\n                Opts\r\n            )\r\n    end;\r\n```",
  "description": "`hb_path.erl` is a foundational module in HyperBEAM that provides utilities for manipulating two distinct types of paths in messages:",
  "hasCode": true
}