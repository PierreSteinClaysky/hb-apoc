{
  "name": "`hb_message",
  "subsystem": "core",
  "filename": "hb_message.erl",
  "content": "# `hb_message.erl` Analysis\r\n\r\n\n\n## Overview\r\n\r\n`hb_message.erl` is a critical module in HyperBEAM that serves as an adapter between different message formats used in the Converge Protocol. With 39 dependents identified in our Stage 1 analysis, it's the fourth most widely-used file in the system, behind only `hb_util.erl`, `hb_converge.erl`, and `hb_opts.erl`.\r\n\r\nThe module abstracts away the complexity of different message serialization formats, providing a unified interface for converting between formats, signing/verifying messages, and extracting message IDs. According to the documentation, the module supports conversion between:\r\n\r\n- Richly typed Converge structured messages\r\n- Arweave transactions\r\n- ANS-104 data items\r\n- HTTP Signed Messages\r\n- Flat Maps\r\n\r\nA distinguishing feature of this module is its use of Type Annotated Binary Messages (TABM) as an intermediate representation. TABMs are deep Erlang maps with keys that only contain either other TABMs or binary values. This normalization simplifies conversions and ensures consistency across different message formats.\r\n\r\n\n\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\nThe module has dependencies on:\r\n- `include/hb.hrl` for system-wide macros and definitions\r\n- `include_lib(\"eunit/include/eunit.hrl\")` for test scaffolding\r\n- `dev_message` for basic message operations\r\n- `dev_codec_*` modules that implement specific format conversions\r\n- `hb_converge` for message resolution and access\r\n- `hb_util` for utility functions and ID formatting\r\n- `hb_path` for hashpath generation\r\n- `hb_crypto` for cryptographic operations\r\n\r\n### Downstream Dependents\r\n\r\n39 other modules depend on this file according to Stage 1 analysis, making it one of the most critical files in the system.\r\n\r\n\n\n## Key Functions\r\n\r\n### Message Format Conversion\r\n\r\n- `convert/3`, `convert/4`: Converts messages between different formats using TABM as an intermediary\r\n- `to_tabm/3`: Converts a message to TABM format\r\n- `from_tabm/4`: Converts a TABM to the target format\r\n- `get_codec/2`: Gets the codec module for a specific format\r\n- `restore_priv/2`: Preserves private data during conversions\r\n\r\n### Message ID Management\r\n\r\n- `id/1`, `id/2`, `id/3`: Returns the ID of a message, with optional attestor filtering\r\n- `type/1`: Determines the type of an encoded message (binary, shallow map, deep map, TX)\r\n\r\n### Message Signing and Verification\r\n\r\n- `attest/2`, `attest/3`: Signs a message with a given wallet\r\n- `verify/1`, `verify/2`: Verifies message signatures\r\n- `unattested/1`: Returns an unsigned version of a message\r\n- `signers/1`: Returns all attestors (signers) of a message\r\n- `attested/1`, `attested/2`, `attested/3`: Returns the list of attested keys in a message\r\n- `with_only_attested/1`, `with_only_attested/2`: Filters a message to include only attested keys\r\n- `with_only_attestors/2`: Filters attestations to include only specified attestors\r\n\r\n### Message Utilities\r\n\r\n- `minimize/1`, `minimize/2`: Removes regeneratable keys from a message\r\n- `normalize/1`: Returns a map with only necessary keys\r\n- `match/2`, `match/3`: Compares two messages for equality\r\n- `find_target/3`: Implements a standard pattern for finding operation targets\r\n\r\n### Debugging Tools\r\n\r\n- `print/1`, `print/2`: Pretty-prints a message\r\n- `format/1`, `format/2`: Formats a message for printing\r\n\r\n\n\n## Usage Patterns\r\n\r\nThe `hb_message` module exhibits several distinctive usage patterns:\r\n\r\n1. **Two-step Conversion Flow**:\r\n   - Conversions always pass through TABM as an intermediate representation\r\n   - First convert source to TABM, then TABM to target format\r\n   - This approach simplifies adding new codecs\r\n\r\n2. **Message Attestation and Verification**:\r\n   - Messages can be cryptographically signed/attested\r\n   - Verification can be performed against all attestors or a subset\r\n   - Keys can be filtered to include only attested ones, protecting against forgery\r\n\r\n3. **ID Generation and Management**:\r\n   - IDs can be generated for attested or unattested messages\r\n   - Multiple ID formats are supported (human-readable, native binary)\r\n   - IDs depend on both message content and attestors\r\n\r\n4. **Message Minimization and Normalization**:\r\n   - Functions to remove unnecessary keys that can be regenerated\r\n   - Normalization ensures consistent key representation\r\n   - Filters out private keys from public views\r\n\r\n\n\n## Integration Points\r\n\r\n`hb_message` integrates with other components through several key mechanisms:\r\n\r\n1. **Device Codec System**:\r\n   - Uses a pluggable codec system where new formats can be added\r\n   - Each codec provides `to/1` and `from/1` functions to convert to/from TABM\r\n\r\n2. **Cache Integration**:\r\n   - Works with `hb_cache` module for storing and retrieving messages\r\n   - Uses TABM as the internal format for the cache\r\n\r\n3. **Converge Protocol**:\r\n   - Provides message verification for the Converge resolution pipeline\r\n   - ID generation functions are critical to message referencing\r\n\r\n4. **Wallet Integration**:\r\n   - Attesting messages requires wallet integration for signing\r\n   - Verification checks signatures against public keys\r\n\r\n5. **Debugging System**:\r\n   - Formatting functions support the debugging infrastructure\r\n   - Special handling for complex fields like hashpaths\r\n\r\n\n\n## Code Snippets\r\n\r\n### Two-Step Conversion Pattern\r\n\r\n```erlang\r\nconvert(Msg, TargetFormat, SourceFormat, Opts) ->\r\n    OldPriv =\r\n        if is_map(Msg) -> maps:get(<<\"priv\">>, Msg, #{});\r\n           true -> #{}\r\n        end,\r\n    TABM =\r\n        to_tabm(\r\n            case is_map(Msg) of\r\n                true -> maps:without([<<\"priv\">>], Msg);\r\n                false -> Msg\r\n            end,\r\n            SourceFormat,\r\n            Opts\r\n        ),\r\n    case TargetFormat of\r\n        tabm -> restore_priv(TABM, OldPriv);\r\n        _ -> from_tabm(TABM, TargetFormat, OldPriv, Opts)\r\n    end.\r\n```\r\n\r\n### Message Attestation\r\n\r\n```erlang\r\nattest(Msg, WalletOrOpts) ->\r\n    attest(\r\n        Msg,\r\n        WalletOrOpts,\r\n        hb_opts:get(\r\n            attestation_device,\r\n            no_viable_attestation_device,\r\n            case is_map(WalletOrOpts) of\r\n                true -> WalletOrOpts;\r\n                false -> #{ priv_wallet => WalletOrOpts }\r\n            end\r\n        )\r\n    ).\r\n```\r\n\r\n### Message Attested Key Filtering\r\n\r\n```erlang\r\nwith_only_attested(Msg, Opts) when is_map(Msg) ->\r\n    Atts = maps:get(<<\"attestations\">>, Msg, not_found),\r\n    case is_map(Msg) andalso Atts /= not_found of\r\n        true ->\r\n            try\r\n                AttestedKeys =\r\n                    hb_message:attested(\r\n                        Msg,\r\n                        #{ <<\"attestors\">> => <<\"all\">> },\r\n                        Opts\r\n                    ),\r\n                % Add the inline-body-key to the attested list if it is not\r\n                % already present.\r\n                ?event({attested_keys, AttestedKeys, {msg, Msg}}),\r\n                {ok, maps:with(\r\n                    AttestedKeys ++ [<<\"attestations\">>],\r\n                    Msg\r\n                )}\r\n            catch _:_:St ->\r\n                {error, {could_not_normalize, Msg, St}}\r\n            end;\r\n        false -> {ok, Msg}\r\n    end;\r\n```",
  "description": "`hb_message.erl` is a critical module in HyperBEAM that serves as an adapter between different message formats used in the Converge Protocol. With 39 dependents identified in our Stage 1 analysis, it's the fourth most widely-used file in the system, behind only `hb_util.erl`, `hb_converge.erl`, and `hb_opts.erl`.",
  "hasCode": true
}