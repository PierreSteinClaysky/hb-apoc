{
  "id": "dev_scheduler",
  "name": "dev_scheduler.erl",
  "filename": "dev_scheduler.erl",
  "category": "scheduler",
  "sections": {
    "overview": "`dev_scheduler.erl` implements a scheduler device for the HyperBEAM system, serving as the core component for process and message management. This module is responsible for orchestrating the execution order of messages within processes, maintaining a consistent execution history, and coordinating between local and remote schedulers in a distributed environment.\r\n\r\nThe scheduler operates on a slot-based model, where each message is assigned to a specific numeric slot for execution. This deterministic ordering ensures that all nodes processing the same messages will arrive at the same state, which is crucial for maintaining consistency in a distributed system.\r\n\r\nAs noted in the module's documentation, the scheduler device accepts and responds to various HTTP-like requests, exposing endpoints for retrieving information, checking slots, managing schedules, and scheduling new messages.",
    "keyCharacteristics": "- **Slot-Based Scheduling**: Assigns messages to specific numbered slots for deterministic execution\r\n- **Process Management**: Tracks and manages processes and their associated message schedules\r\n- **Local and Remote Operation**: Supports both local execution and redirection to remote schedulers\r\n- **Format Adaptation**: Handles multiple protocol variants and format representations\r\n- **Service Registration**: Provides registry mechanisms for scheduler locations\r\n- **HTTP Integration**: Designed to work seamlessly within an HTTP-based interface\r\n- **Checkpoint Support**: Enables state persistence and recovery\r\n- **Format Flexibility**: Supports multiple response formats including application/http and application/aos-2",
    "dependencies": "#",
    "implementationDetails": "#",
    "integrationWithHyperBEAM": "",
    "testingApproach": "",
    "observations": "",
    "architecturalSignificance": "",
    "conclusion": "",
    "strengths": "",
    "designPatterns": "",
    "challenges": "",
    "futureOpportunities": ""
  },
  "metadata": {
    "hasTests": false,
    "dependencies": [],
    "analysisCompleteness": 22,
    "source": {
      "originalFile": "01_dev_scheduler_analysis.md",
      "parsedDate": "2025-03-27T19:20:21.831Z"
    }
  },
  "originalContent": "# `dev_scheduler.erl` Analysis\r\n\r\n## Overview\r\n\r\n`dev_scheduler.erl` implements a scheduler device for the HyperBEAM system, serving as the core component for process and message management. This module is responsible for orchestrating the execution order of messages within processes, maintaining a consistent execution history, and coordinating between local and remote schedulers in a distributed environment.\r\n\r\nThe scheduler operates on a slot-based model, where each message is assigned to a specific numeric slot for execution. This deterministic ordering ensures that all nodes processing the same messages will arrive at the same state, which is crucial for maintaining consistency in a distributed system.\r\n\r\nAs noted in the module's documentation, the scheduler device accepts and responds to various HTTP-like requests, exposing endpoints for retrieving information, checking slots, managing schedules, and scheduling new messages.\r\n\r\n## Key Characteristics\r\n\r\n- **Slot-Based Scheduling**: Assigns messages to specific numbered slots for deterministic execution\r\n- **Process Management**: Tracks and manages processes and their associated message schedules\r\n- **Local and Remote Operation**: Supports both local execution and redirection to remote schedulers\r\n- **Format Adaptation**: Handles multiple protocol variants and format representations\r\n- **Service Registration**: Provides registry mechanisms for scheduler locations\r\n- **HTTP Integration**: Designed to work seamlessly within an HTTP-based interface\r\n- **Checkpoint Support**: Enables state persistence and recovery\r\n- **Format Flexibility**: Supports multiple response formats including application/http and application/aos-2\r\n\r\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_converge`: For message resolution and processing\r\n- `hb_message`: For message attestation and verification\r\n- `hb_private`: For storing private data in messages\r\n- `hb_http`: For HTTP communication with remote schedulers\r\n- `hb_cache`: For caching message data and assignments\r\n- `hb_gateway_client`: For interacting with Arweave gateways\r\n- `dev_scheduler_registry`: For registering and finding processes\r\n- `dev_scheduler_server`: For scheduling operations on specific processes\r\n- `dev_scheduler_cache`: For caching schedule information\r\n- `dev_scheduler_formats`: For format conversions\r\n- `ar_timestamp`: For timestamp handling\r\n- `crypto`: For random number generation\r\n- `jiffy`: For JSON encoding/decoding\r\n\r\n## Implementation Details\r\n\r\n### Default Handler and Routing\r\n\r\nThe module follows a device pattern with a default handler that routes requests based on their method and path:\r\n\r\n```erlang\r\ninfo() -> \r\n    #{\r\n        exports =>\r\n            [\r\n                register,\r\n                status,\r\n                next,\r\n                schedule,\r\n                slot,\r\n                init,\r\n                checkpoint\r\n            ],\r\n        excludes => [set, keys],\r\n        default => fun router/4\r\n    }.\r\n\r\nrouter(_, Msg1, Msg2, Opts) ->\r\n    ?event({scheduler_router_called, {msg2, Msg2}, {opts, Opts}}),\r\n    schedule(Msg1, Msg2, Opts).\r\n```\r\n\r\nThe `router/4` function handles incoming requests and dispatches them to appropriate handlers. For schedule-related operations, it further routes to specific handlers based on the HTTP method:\r\n\r\n```erlang\r\nschedule(Msg1, Msg2, Opts) ->\r\n    ?event({resolving_schedule_request, {msg2, Msg2}, {state_msg, Msg1}}),\r\n    case hb_converge:get(<<\"method\">>, Msg2, <<\"GET\">>, Opts) of\r\n        <<\"POST\">> -> post_schedule(Msg1, Msg2, Opts);\r\n        <<\"GET\">> -> get_schedule(Msg1, Msg2, Opts)\r\n    end.\r\n```\r\n\r\n### Process and Schedule Management\r\n\r\nThe scheduler handles the registration and management of processes:\r\n\r\n```erlang\r\nregister(_Msg1, Req, Opts) ->\r\n    % Ensure that the request is signed by the operator.\r\n    ?event({registering_scheduler, {msg1, _Msg1}, {req, Req}, {opts, Opts}}),\r\n    {ok, OnlyAttested} = hb_message:with_only_attested(Req),\r\n    % ... validation logic ...\r\n    \r\n    % Construct the new scheduler location message.\r\n    NewSchedulerLocation = #{\r\n        <<\"data-protocol\">> => <<\"ao\">>,\r\n        <<\"variant\">> => <<\"ao.N.1\">>,\r\n        <<\"type\">> => <<\"scheduler-location\">>,\r\n        <<\"url\">> => URL,\r\n        <<\"nonce\">> => NewNonce,\r\n        <<\"time-to-live\">> => TimeToLive,\r\n        <<\"codec-device\">> => Codec\r\n    },\r\n    Signed = hb_message:attest(NewSchedulerLocation, Opts, Codec),\r\n    % ... upload logic ...\r\n    {ok, Signed}\r\n```\r\n\r\nThe scheduler supports finding the appropriate server for a given process, either locally or remotely:\r\n\r\n```erlang\r\nfind_server(ProcID, Msg1, ToSched, Opts) ->\r\n    case get_hint(ProcID, Opts) of\r\n        {ok, Hint} ->\r\n            ?event({found_hint_in_proc_id, Hint}),\r\n            generate_redirect(ProcID, Hint, Opts);\r\n        not_found ->\r\n            ?event({no_hint_in_proc_id, ProcID}),\r\n            case dev_scheduler_registry:find(ProcID, false, Opts) of\r\n                PID when is_pid(PID) ->\r\n                    ?event({found_pid_in_local_registry, PID}),\r\n                    {local, PID};\r\n                not_found ->\r\n                    % ... complex logic to find process and determine scheduler ...\r\n            end\r\n    end.\r\n```\r\n\r\n### Slot Management\r\n\r\nThe module provides a function to determine the current slot for a process:\r\n\r\n```erlang\r\nslot(M1, M2, Opts) ->\r\n    ?event({getting_current_slot, {msg, M1}}),\r\n    ProcID = find_target_id(M1, M2, Opts),\r\n    case find_server(ProcID, M1, Opts) of\r\n        {local, PID} ->\r\n            ?event({getting_current_slot, {proc_id, ProcID}}),\r\n            {Timestamp, Hash, Height} = ar_timestamp:get(),\r\n            #{ current := CurrentSlot, wallet := Wallet } =\r\n                dev_scheduler_server:info(PID),\r\n            {ok, #{\r\n                <<\"process\">> => ProcID,\r\n                <<\"current\">> => CurrentSlot,\r\n                <<\"timestamp\">> => Timestamp,\r\n                <<\"block-height\">> => Height,\r\n                <<\"block-hash\">> => Hash,\r\n                <<\"cache-control\">> => <<\"no-store\">>,\r\n                <<\"wallet-address\">> => hb_util:human_id(ar_wallet:to_address(Wallet))\r\n            }};\r\n        {redirect, Redirect} ->\r\n            % ... remote slot handling ...\r\n    end.\r\n```\r\n\r\nFor remote slots, the module handles protocol variants:\r\n\r\n```erlang\r\nremote_slot(<<\"ao.N.1\">>, ProcID, Node, Opts) ->\r\n    % The process is running on a mainnet AO-Core scheduler, so we can just\r\n    % use the `/slot' endpoint to get the current slot.\r\n    ?event({getting_slot_from_ao_core_remote,\r\n        {path, {string, <<\"/\", ProcID/binary, \"/slot\">>}}}),\r\n    hb_http:get(Node, <<ProcID/binary, \"/slot\">>, Opts);\r\n\r\nremote_slot(<<\"ao.TN.1\">>, ProcID, Node, Opts) ->\r\n    % The process is running on a testnet AO-Core scheduler, so we need to use\r\n    % `/processes/procID/latest` to get the current slot.\r\n    Path = << ProcID/binary, \"/latest?proc-id=\", ProcID/binary>>,\r\n    % ... complex handling for testnet format ...\r\n```\r\n\r\n### Next Message Determination\r\n\r\nThe scheduler determines the next message to process for a given process:\r\n\r\n```erlang\r\nnext(Msg1, Msg2, Opts) ->\r\n    ?event(next, {scheduler_next_called, {msg1, Msg1}, {msg2, Msg2}}),\r\n    Schedule =\r\n        hb_private:get(\r\n            <<\"priv/scheduler/assignments\">>,\r\n            Msg1,\r\n            Opts\r\n        ),\r\n    LastProcessed = hb_util:int(hb_converge:get(<<\"at-slot\">>, Msg1, Opts)),\r\n    % ... schedule handling logic ...\r\n    \r\n    case (LastProcessed + 1) == Slot of\r\n        true ->\r\n            NextMessage =\r\n                hb_converge:get(\r\n                    Slot,\r\n                    FilteredAssignments,\r\n                    Opts\r\n                ),\r\n            NextState =\r\n                hb_private:set(\r\n                    Msg1,\r\n                    <<\"schedule/assignments\">>,\r\n                    hb_converge:remove(FilteredAssignments, Slot),\r\n                    Opts\r\n                ),\r\n            ?event(next,\r\n                {next_returning, {slot, Slot}, {message, NextMessage}}),\r\n            {ok, #{ <<\"body\">> => NextMessage, <<\"state\">> => NextState }};\r\n        false ->\r\n            {error,\r\n                #{\r\n                    <<\"status\">> => 503,\r\n                    <<\"body\">> => <<\"No assignment found for next slot.\">>\r\n                }\r\n            }\r\n    end.\r\n```\r\n\r\n### Remote Integration\r\n\r\nThe module handles routing to remote schedulers when necessary:\r\n\r\n```erlang\r\ngenerate_redirect(ProcID, SchedulerLocation, Opts) ->\r\n    Variant = hb_converge:get(<<\"variant\">>, SchedulerLocation, <<\"ao.N.1\">>, Opts),\r\n    ?event({generating_redirect, {proc_id, ProcID}, {variant, Variant}}),\r\n    RedirectLocation =\r\n        case is_binary(SchedulerLocation) of\r\n            true -> SchedulerLocation;\r\n            false ->\r\n                hb_converge:get_first(\r\n                    [\r\n                        {SchedulerLocation, <<\"url\">>},\r\n                        {SchedulerLocation, <<\"location\">>}\r\n                    ],\r\n                    <<\"/\">>,\r\n                    Opts\r\n                )\r\n        end,\r\n    {redirect,\r\n        #{\r\n            <<\"status\">> => 307,\r\n            <<\"location\">> => RedirectLocation,\r\n            <<\"body\">> =>\r\n                <<\"Redirecting to scheduler: \", RedirectLocation/binary>>,\r\n            <<\"variant\">> => Variant\r\n        }\r\n    }.\r\n```\r\n\r\nFor remote schedule operations, it handles different protocol variants:\r\n\r\n```erlang\r\npost_remote_schedule(RawProcID, Redirect, OnlyAttested, Opts) ->\r\n    RemoteOpts = Opts#{ http_client => httpc },\r\n    ProcID = without_hint(RawProcID),\r\n    Location = hb_converge:get(<<\"location\">>, Redirect, Opts),\r\n    Parsed = uri_string:parse(Location),\r\n    Node = uri_string:recompose((maps:remove(query, Parsed))#{path => <<\"/\">>}),\r\n    Variant = hb_converge:get(<<\"variant\">>, Redirect, <<\"ao.N.1\">>, Opts),\r\n    case Variant of\r\n        <<\"ao.N.1\">> ->\r\n            PostMsg = #{\r\n                <<\"path\">> => << ProcID/binary, \"/schedule\">>,\r\n                <<\"body\">> => OnlyAttested,\r\n                <<\"method\">> => <<\"POST\">>\r\n            },\r\n            hb_http:post(Node, PostMsg, RemoteOpts);\r\n        <<\"ao.TN.1\">> ->\r\n            post_legacy_schedule(ProcID, OnlyAttested, Node, RemoteOpts)\r\n    end.\r\n```\r\n\r\nThe module also handles legacy format adaptations:\r\n\r\n```erlang\r\npost_legacy_schedule(ProcID, OnlyAttested, Node, Opts) ->\r\n    ?event({encoding_for_legacy_scheduler, {node, {string, Node}}}),\r\n    Encoded =\r\n        try\r\n            Item =\r\n                hb_message:convert(\r\n                    OnlyAttested,\r\n                    <<\"ans104@1.0\">>,\r\n                    Opts\r\n                ),\r\n            ?event(ans104, {encoded_for_legacy_scheduler, {item, Item}, {exact, {explicit, Item}}}),\r\n            {ok, ar_bundles:serialize(Item)}\r\n        catch\r\n            _:_ ->\r\n                {error,\r\n                    #{\r\n                        <<\"status\">> => 422,\r\n                        <<\"body\">> =>\r\n                            <<\r\n                                \"Failed to post schedule on \", Node/binary,\r\n                                \" for \", ProcID/binary, \". Try different encoding?\"\r\n                            >>\r\n                    }\r\n                }\r\n        end,\r\n    % ... further handling and HTTP posting ...\r\n```\r\n\r\n## Questions and Insights\r\n\r\n### Questions\r\n\r\n1. **Concurrent Process Handling**: How does the scheduler handle multiple concurrent processes? Is there a limit to the number of processes that can be managed concurrently?\r\n\r\n2. **Failure Recovery**: How does the system handle scheduler failures or process failures? How are schedules recovered or synchronized after a node restart?\r\n\r\n3. **Determinism Guarantees**: What mechanisms ensure that the scheduling is fully deterministic across nodes, especially when considering network delays or failures?\r\n\r\n4. **Scale Considerations**: How does the scheduler design scale with increasing numbers of processes and messages? Are there potential bottlenecks in the current architecture?\r\n\r\n5. **Format Evolution**: How is the evolution of scheduling protocols and formats managed? What is the strategy for transitioning between versions?\r\n\r\n### Insights\r\n\r\n1. **Hybrid Architecture**: The scheduler implements a hybrid architecture that supports both local processing and remote redirection, enabling flexible deployment models.\r\n\r\n2. **Protocol Adaptation**: The module demonstrates sophisticated protocol adaptation capabilities, handling different variants and formats to maintain compatibility with both mainnet and testnet environments.\r\n\r\n3. **Idempotent Design**: The slot-based approach provides natural idempotence, as messages are assigned to specific slots regardless of how many times they are submitted.\r\n\r\n4. **Cryptographic Trust**: The scheduler relies on message attestation and verification for security, ensuring that only properly signed messages can be scheduled.\r\n\r\n5. **Testing Focus**: The extensive test suite indicates a strong focus on reliability and correctness, with benchmarks suggesting performance is also a consideration.\r\n\r\n## Integration with Other Subsystems\r\n\r\n### Integration with Device and Process Management Subsystem\r\n\r\n- Works with `dev_scheduler_registry` for process registration and lookup\r\n- Interfaces with `dev_scheduler_server` for per-process scheduling operations\r\n- Uses `dev_scheduler_cache` for schedule data caching\r\n- Relies on `dev_scheduler_formats` for format adaptations\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Leverages `hb_converge` for message resolution and manipulation\r\n- Uses `hb_message` for message attestation and verification\r\n- Employs `hb_private` for private data storage\r\n- Depends on `hb_cache` for data caching\r\n- Utilizes `hb_opts` for configuration access\r\n\r\n### Integration with Network Communication Subsystem\r\n\r\n- Uses `hb_http` for communication with remote schedulers\r\n- Relies on `hb_gateway_client` for Arweave gateway interactions\r\n- Handles HTTP-like request and response formats\r\n\r\n### Integration with Arweave Subsystem\r\n\r\n- Interfaces with `ar_timestamp` for blockchain timestamp information\r\n- Uses Arweave wallet addresses for process authority\r\n\r\n## Recategorization Considerations\r\n\r\nThis module is correctly categorized as part of the Device and Process Management Subsystem. Its primary responsibility is scheduling, which is a fundamental aspect of process management in the HyperBEAM system.\r\n\r\nWhile it has strong connections to the Network Communication Subsystem through its HTTP interactions and to the Arweave Subsystem through its use of wallet addresses and timestamps, its core functionality revolves around managing the execution order of messages within processes, which is a process management concern.\r\n\r\nThe module also demonstrates the device-centric architecture of HyperBEAM, where functionality is exposed through a standardized device interface, further reinforcing its categorization within the Device and Process Management Subsystem.\r\n"
}