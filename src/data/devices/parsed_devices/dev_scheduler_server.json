{
  "id": "dev_scheduler_server",
  "name": "dev_scheduler_server.erl",
  "filename": "dev_scheduler_server.erl",
  "category": "scheduler",
  "sections": {
    "overview": "`dev_scheduler_server.erl` implements a server component for the HyperBEAM scheduler system that manages the assignment of messages to specific slots within a process. As noted in its documentation, it \"acts as a deliberate 'bottleneck' to prevent the server accidentally assigning multiple messages to the same slot,\" highlighting its role in maintaining ordering guarantees within the system.\r\n\r\nThis module is designed as a long-lived Erlang process that maintains state for a specific process ID, including the current slot number and a cryptographic hash chain that links all assignments together. When a message is scheduled, the server assigns it to the next available slot, updates the hash chain, and creates an assignment message that is persisted to storage and potentially uploaded to the network.\r\n\r\nThe server supports different scheduling modes that provide different trade-offs between performance and confirmation guarantees, ranging from aggressive asynchronous scheduling to fully synchronized operations that wait for network confirmation.",
    "keyCharacteristics": "- **Sequential Assignment**: Ensures messages are assigned to sequential slots without gaps or duplicates\r\n- **Hash Chain Management**: Maintains a cryptographic chain linking all assignments together\r\n- **Multiple Scheduling Modes**: Supports different performance/reliability trade-offs through configurable modes\r\n- **Process-Per-ID Model**: Creates a dedicated Erlang process for each HyperBEAM process ID\r\n- **State Management**: Maintains and persists state between restarts\r\n- **Erlang Message Passing**: Uses Erlang's message passing for communication\r\n- **Blockchain Integration**: Includes Arweave blockchain metadata in assignments",
    "dependencies": "#",
    "implementationDetails": "#",
    "integrationWithHyperBEAM": "",
    "testingApproach": "",
    "observations": "",
    "architecturalSignificance": "",
    "conclusion": "",
    "strengths": "",
    "designPatterns": "",
    "challenges": "",
    "futureOpportunities": ""
  },
  "metadata": {
    "hasTests": false,
    "dependencies": [],
    "analysisCompleteness": 22,
    "source": {
      "originalFile": "05_dev_scheduler_server_analysis.md",
      "parsedDate": "2025-03-27T19:20:21.835Z"
    }
  },
  "originalContent": "# `dev_scheduler_server.erl` Analysis\r\n\r\n## Overview\r\n\r\n`dev_scheduler_server.erl` implements a server component for the HyperBEAM scheduler system that manages the assignment of messages to specific slots within a process. As noted in its documentation, it \"acts as a deliberate 'bottleneck' to prevent the server accidentally assigning multiple messages to the same slot,\" highlighting its role in maintaining ordering guarantees within the system.\r\n\r\nThis module is designed as a long-lived Erlang process that maintains state for a specific process ID, including the current slot number and a cryptographic hash chain that links all assignments together. When a message is scheduled, the server assigns it to the next available slot, updates the hash chain, and creates an assignment message that is persisted to storage and potentially uploaded to the network.\r\n\r\nThe server supports different scheduling modes that provide different trade-offs between performance and confirmation guarantees, ranging from aggressive asynchronous scheduling to fully synchronized operations that wait for network confirmation.\r\n\r\n## Key Characteristics\r\n\r\n- **Sequential Assignment**: Ensures messages are assigned to sequential slots without gaps or duplicates\r\n- **Hash Chain Management**: Maintains a cryptographic chain linking all assignments together\r\n- **Multiple Scheduling Modes**: Supports different performance/reliability trade-offs through configurable modes\r\n- **Process-Per-ID Model**: Creates a dedicated Erlang process for each HyperBEAM process ID\r\n- **State Management**: Maintains and persists state between restarts\r\n- **Erlang Message Passing**: Uses Erlang's message passing for communication\r\n- **Blockchain Integration**: Includes Arweave blockchain metadata in assignments\r\n\r\n## Dependencies\r\n\r\n### Upstream Dependencies\r\n\r\n- `hb_name`: For process registration\r\n- `dev_scheduler_cache`: For persisting and retrieving assignments\r\n- `hb_message`: For creating attested assignment messages\r\n- `hb_client`: For uploading assignments to the network\r\n- `hb_path`: For path extraction from messages\r\n- `hb_opts`: For configuration options\r\n- `ar_timestamp`: For obtaining blockchain timing information\r\n- `hb`: For wallet access\r\n\r\n## Implementation Details\r\n\r\n### Server Initialization\r\n\r\nThe `start/2` function initializes a new scheduler server process:\r\n\r\n```erlang\r\nstart(ProcID, Opts) ->\r\n    ?event(scheduling, {starting_scheduling_server, {proc_id, ProcID}}),\r\n    spawn_link(\r\n        fun() ->\r\n            case hb_opts:get(scheduling_mode, disabled, Opts) of\r\n                disabled ->\r\n                    throw({scheduling_disabled_on_node, {requested_for, ProcID}});\r\n                _ -> ok\r\n            end,\r\n            hb_name:register({dev_scheduler, ProcID}),\r\n            {CurrentSlot, HashChain} =\r\n                case dev_scheduler_cache:latest(ProcID, Opts) of\r\n                    not_found ->\r\n                        ?event({starting_new_schedule, {proc_id, ProcID}}),\r\n                        {-1, <<>>};\r\n                    {Slot, Chain} ->\r\n                        ?event({continuing_schedule, {proc_id, ProcID}, {current_slot, Slot}}),\r\n                        {Slot, Chain}\r\n                end,\r\n            ?event(\r\n                {scheduler_got_process_info,\r\n                    {proc_id, ProcID},\r\n                    {current, CurrentSlot},\r\n                    {hash_chain, HashChain}\r\n                }\r\n            ),\r\n            server(\r\n                #{\r\n                    id => ProcID,\r\n                    current => CurrentSlot,\r\n                    wallet => hb_opts:get(priv_wallet, hb:wallet(), Opts),\r\n                    hash_chain => HashChain,\r\n                    opts => Opts\r\n                }\r\n            )\r\n        end\r\n    ).\r\n```\r\n\r\nThis function:\r\n1. Checks if scheduling is enabled for the node\r\n2. Registers the process with the naming service\r\n3. Retrieves the current state (slot and hash chain) from the cache if available, or initializes new state if not\r\n4. Starts the server loop with the initial state\r\n\r\n### Message Scheduling\r\n\r\nThe `schedule/2` function is the main interface for scheduling messages:\r\n\r\n```erlang\r\nschedule(AOProcID, Message) when is_binary(AOProcID) ->\r\n    schedule(dev_scheduler_registry:find(AOProcID), Message);\r\nschedule(ErlangProcID, Message) ->\r\n    ErlangProcID ! {schedule, Message, self()},\r\n    receive\r\n        {scheduled, Message, Assignment} ->\r\n            Assignment\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Resolves the process ID to an Erlang PID if necessary\r\n2. Sends a scheduling request to the scheduler process\r\n3. Waits for a confirmation response with the assignment\r\n\r\n### Assignment Creation\r\n\r\nThe core scheduling logic is in the `do_assign/3` function:\r\n\r\n```erlang\r\ndo_assign(State, Message, ReplyPID) ->\r\n    HashChain = next_hashchain(maps:get(hash_chain, State), Message),\r\n    NextSlot = maps:get(current, State) + 1,\r\n    % Run the signing of the assignment and writes to the disk in a separate\r\n    % process.\r\n    AssignFun =\r\n        fun() ->\r\n            {Timestamp, Height, Hash} = ar_timestamp:get(),\r\n            Assignment = hb_message:attest(#{\r\n                <<\"path\">> =>\r\n                    case hb_path:from_message(request, Message) of\r\n                        undefined -> <<\"compute\">>;\r\n                        Path -> Path\r\n                    end,\r\n                <<\"data-protocol\">> => <<\"ao\">>,\r\n                <<\"variant\">> => <<\"ao.N.1\">>,\r\n                <<\"process\">> => hb_util:id(maps:get(id, State)),\r\n                <<\"epoch\">> => <<\"0\">>,\r\n                <<\"slot\">> => NextSlot,\r\n                <<\"block-height\">> => Height,\r\n                <<\"block-hash\">> => hb_util:human_id(Hash),\r\n                <<\"block-timestamp\">> => Timestamp,\r\n                % Note: Local time on the SU, not Arweave\r\n                <<\"timestamp\">> => erlang:system_time(millisecond),\r\n                <<\"hash-chain\">> => hb_util:id(HashChain),\r\n                <<\"body\">> => Message\r\n            }, maps:get(wallet, State)),\r\n            % ... storage and reply logic ...\r\n        end,\r\n    % ... scheduling mode handling ...\r\n    State#{\r\n        current := NextSlot,\r\n        hash_chain := HashChain\r\n    }.\r\n```\r\n\r\nThis function:\r\n1. Creates the next hash chain link\r\n2. Determines the next slot number\r\n3. Creates an assignment message with blockchain metadata, process information, and the message itself\r\n4. Handles storage, network upload, and client notification based on the scheduling mode\r\n5. Updates and returns the server state\r\n\r\n### Hash Chain Management\r\n\r\nThe `next_hashchain/2` function maintains the cryptographic chain of assignments:\r\n\r\n```erlang\r\nnext_hashchain(HashChain, Message) ->\r\n    ?event({creating_next_hashchain, {hash_chain, HashChain}, {message, Message}}),\r\n    ID = hb_message:id(Message, all),\r\n    crypto:hash(\r\n        sha256,\r\n        << HashChain/binary, ID/binary >>\r\n    ).\r\n```\r\n\r\nThis function:\r\n1. Extracts the content-addressed ID of the message\r\n2. Concatenates it with the previous hash chain\r\n3. Computes a new SHA-256 hash of the combined data\r\n\r\n### Scheduling Modes\r\n\r\nThe module supports different scheduling modes, implemented in the `maybe_inform_recipient/5` function:\r\n\r\n```erlang\r\nmaybe_inform_recipient(Mode, ReplyPID, Message, Assignment, State) ->\r\n    case hb_opts:get(scheduling_mode, remote_confirmation, maps:get(opts, State)) of\r\n        Mode -> ReplyPID ! {scheduled, Message, Assignment};\r\n        _ -> ok\r\n    end.\r\n```\r\n\r\nThis function:\r\n1. Checks if the current scheduling mode matches the requested notification mode\r\n2. Sends a confirmation message to the client if the modes match\r\n\r\nThe supported modes are:\r\n- `aggressive`: Responds immediately and performs the assignment in a separate process\r\n- `local_confirmation`: Responds after writing to local storage\r\n- `remote_confirmation`: Responds after uploading to the network\r\n\r\n## Questions and Insights\r\n\r\n### Questions\r\n\r\n1. **Concurrency Control**: How does the system handle concurrent scheduling requests for the same process? Is there a mechanism to prevent race conditions between multiple instances of scheduling servers?\r\n\r\n2. **Failure Recovery**: What happens if the scheduling server crashes during an assignment operation? How is consistency maintained in such scenarios?\r\n\r\n3. **Network Partition Handling**: How does the system handle network partitions, particularly in `remote_confirmation` mode where uploads are expected to succeed?\r\n\r\n4. **Performance Implications**: What are the performance implications of the different scheduling modes? Are there benchmarks or guidelines for choosing between them?\r\n\r\n5. **Backward Compatibility**: How does the server handle backward compatibility with older message formats or hash chain algorithms?\r\n\r\n### Insights\r\n\r\n1. **Deliberate Bottleneck**: The server is explicitly designed as a bottleneck, which is an interesting architectural choice. This indicates a deliberate trade-off between parallelism and sequential consistency.\r\n\r\n2. **Cryptographic Continuity**: The hash chain mechanism ensures that each assignment is cryptographically linked to its predecessors, creating a verifiable history of assignments.\r\n\r\n3. **Flexible Confirmation Models**: The three scheduling modes provide a spectrum of confirmation guarantees, allowing applications to choose the right balance between performance and reliability.\r\n\r\n4. **State Persistence**: The server is designed to recover its state from persistent storage, allowing it to continue from the correct slot after restarts.\r\n\r\n5. **Blockchain Integration**: The inclusion of Arweave blockchain metadata in assignments ties the scheduler to the blockchain timeline, potentially enabling external verification.\r\n\r\n## Integration with Other Subsystems\r\n\r\n### Integration with Device and Process Management Subsystem\r\n\r\n- Works with `dev_scheduler_registry` for process discovery and creation\r\n- Provides the core scheduling logic for `dev_scheduler`\r\n- Maintains the state that other scheduler components refer to\r\n\r\n### Integration with Storage Subsystem\r\n\r\n- Uses `dev_scheduler_cache` for persisting and retrieving assignments\r\n- Creates a permanent record of assignments for future reference\r\n\r\n### Integration with Network Communication Subsystem\r\n\r\n- Uses `hb_client` to upload assignments to the network\r\n- Potentially waits for network confirmation in `remote_confirmation` mode\r\n\r\n### Integration with Core Infrastructure\r\n\r\n- Uses `hb_message` for message attestation\r\n- Uses `hb_name` for process registration\r\n- Uses `hb_opts` for configuration access\r\n\r\n### Integration with Arweave Subsystem\r\n\r\n- Uses `ar_timestamp` to obtain blockchain timing information\r\n- Incorporates blockchain metadata into assignments\r\n\r\n## Recategorization Considerations\r\n\r\nThis module is correctly categorized as part of the Device and Process Management Subsystem. Its primary responsibility is managing the scheduling of messages within processes, which is a core aspect of process management.\r\n\r\nThe module's tight integration with other scheduler components (`dev_scheduler_registry`, `dev_scheduler_cache`) and its focused responsibility of maintaining the sequential order of message execution further reinforce its categorization.\r\n\r\nWhile it interacts with other subsystems such as storage and network, these interactions are in service of its primary process management responsibility. The deliberate design as a bottleneck for sequential processing also aligns with the process management paradigm rather than with the patterns typical of other subsystems.\r\n"
}